<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3-Panel Viewer - OSM | Embeddings | RGB</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            background: #2a2a2a;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #controls h1 {
            font-size: 18px;
            font-weight: 600;
            margin-right: 20px;
        }

        #controls label {
            font-size: 14px;
            margin-right: 5px;
        }

        #controls select,
        #controls input {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #fff;
            font-size: 14px;
        }

        #controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 0.2s;
        }

        .save-btn {
            background: #28a745;
            color: white;
        }

        .save-btn:hover {
            background: #218838;
        }

        .clear-btn {
            background: #dc3545;
            color: white;
        }

        .clear-btn:hover {
            background: #c82333;
        }

        .export-btn {
            background: #007bff;
            color: white;
        }

        .export-btn:hover {
            background: #0056b3;
        }

        #label-count {
            padding: 8px 12px;
            background: #333;
            border-radius: 4px;
            font-weight: 600;
        }

        #map-container {
            position: fixed;
            top: 110px;
            left: 0;
            right: 0;
            bottom: 40px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 2px;
            background: #1a1a1a;
        }

        .panel {
            position: relative;
            background: #2a2a2a;
        }

        .panel-header {
            position: absolute;
            top: 45px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 14px;
            z-index: 400;
            backdrop-filter: blur(5px);
        }

        .map {
            width: 100%;
            height: 100%;
        }

        #status {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2a2a2a;
            padding: 10px 20px;
            font-size: 12px;
            color: #999;
            border-top: 1px solid #333;
        }

        .marker-popup {
            font-size: 14px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1 id="viewer-title">3-Panel Viewer</h1>

        <!-- Labeling Controls -->
        <div style="display: flex; gap: 10px; align-items: center;">
            <button style="background: #17a2b8; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;" onclick="createLabelDialog()">+ Create Label</button>

            <label style="margin: 0;">Active Label:</label>
            <select id="active-label" style="padding: 8px 12px; border: 1px solid #444; border-radius: 4px; background: #333; color: #fff; font-size: 14px;">
                <option value="">No labels yet</option>
            </select>

            <button id="start-label-btn" style="background: #28a745; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;" onclick="startLabeling()">Start Labeling</button>
            <button id="stop-label-btn" style="background: #dc3545; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; display: none;" onclick="stopLabeling()">Stop Labeling</button>

            <button style="background: #007bff; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;" onclick="exportLabelsJSON()">Export Labels</button>

            <button style="background: #17a2b8; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;" onclick="document.getElementById('import-labels-file').click()">Import Labels</button>
            <input type="file" id="import-labels-file" accept=".json" style="display: none;" onchange="importLabelsJSON(event)">

            <!-- Similarity Search Controls -->
            <div style="display: flex; gap: 10px; align-items: center; margin-left: 20px; border-left: 1px solid #444; padding-left: 20px;">
                <label style="margin: 0;">Similarity:</label>
                <input
                    type="range"
                    id="similarity-threshold"
                    min="0"
                    max="100"
                    value="50"
                    style="width: 120px; cursor: pointer;"
                    oninput="updateThresholdDisplay()"
                />
                <span id="threshold-display" style="background: #333; padding: 4px 8px; border-radius: 3px; font-size: 13px; min-width: 40px; text-align: center;">5.00</span>

                <button
                    id="find-similar-btn"
                    style="background: #17a2b8; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;"
                    onclick="findSimilarPixels()"
                >
                    Find Similar
                </button>

                <button
                    id="commit-similar-btn"
                    style="background: #28a745; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; display: none;"
                    onclick="commitSimilarPixels()"
                >
                    Commit & Relabel (<span id="similar-count">0</span>)
                </button>

                <button
                    id="clear-similar-btn"
                    style="background: #dc3545; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; display: none;"
                    onclick="clearSimilarPixels()"
                >
                    Clear Preview
                </button>
            </div>

            <span id="label-count" style="padding: 8px 12px; background: #333; border-radius: 4px; font-weight: 600; margin-left: 20px;">Labels: 0 | Embeddings: 0</span>
        </div>
    </div>

    <div id="map-container">
        <div class="panel">
            <div class="panel-header">OpenStreetMap</div>
            <div id="map-osm" class="map"></div>
        </div>
        <div class="panel">
            <div class="panel-header">Tessera Embeddings <span id="embedding-year">2024</span></div>
            <div id="map-embedding" class="map"></div>
        </div>
        <div class="panel">
            <div class="panel-header">Satellite RGB</div>
            <div id="map-rgb" class="map"></div>
        </div>
    </div>

    <div id="status">
        <strong>Labeling Instructions:</strong> 1) Create label(s) with "+ Create Label" • 2) Select active label from dropdown • 3) Click "Start Labeling" • 4) Click on embeddings to label them (colors show labels) • 5) Click "Stop Labeling" when done • 6) Click "Export Labels" to save JSON • All maps are synchronized
    </div>

    <script>
        const TILE_SERVER = 'http://localhost:5125';
        let center = [12.97, 77.59];  // Default: Bangalore
        let zoom = 12;

        // Viewport bounds for clipping
        let viewportBounds = null;  // Will be set from updateMapViewport()

        // Current embedding year
        let currentEmbeddingYear = '2024';
        let currentViewportName = 'tile_aligned';

        // Storage for labels: {panel: [[lat, lon, label], ...]}
        let labels = {
            'osm': [],
            'embedding': [],
            'rgb': []
        };

        // Storage for marker objects: {panel: {key: marker}}
        let markers = {
            'osm': {},
            'embedding': {},
            'rgb': {}
        };

        // Map instances
        let maps = {};

        // Fetch current viewport and update map center/zoom
        async function updateMapViewport() {
            try {
                const response = await fetch('/api/viewports/current');
                const data = await response.json();

                if (data.success && data.viewport) {
                    const vp = data.viewport;
                    currentViewportName = vp.name;

                    // Update page title and heading with viewport name
                    const viewportDisplayName = currentViewportName.charAt(0).toUpperCase() + currentViewportName.slice(1);
                    document.title = `${viewportDisplayName} Viewer - OSM | Embeddings | RGB`;
                    const titleEl = document.getElementById('viewer-title');
                    if (titleEl) {
                        titleEl.textContent = `${viewportDisplayName} Viewer`;
                    }

                    // Parse bounds from viewport: [lon_min, lat_min, lon_max, lat_max]
                    if (vp.bounds_tuple && vp.bounds_tuple.length === 4) {
                        const [lonMin, latMin, lonMax, latMax] = vp.bounds_tuple;

                        // Store viewport bounds in Leaflet format: [[latMin, lonMin], [latMax, lonMax]]
                        viewportBounds = [[latMin, lonMin], [latMax, lonMax]];

                        // Calculate center (Leaflet expects [lat, lon])
                        center = [(latMin + latMax) / 2, (lonMin + lonMax) / 2];

                        // Calculate zoom level based on bounds
                        // Roughly: larger bounds = lower zoom, smaller bounds = higher zoom
                        const latSpan = latMax - latMin;
                        const lonSpan = lonMax - lonMin;
                        const maxSpan = Math.max(latSpan, lonSpan);

                        if (maxSpan > 0.5) zoom = 11;
                        else if (maxSpan > 0.2) zoom = 12;
                        else if (maxSpan > 0.1) zoom = 13;
                        else if (maxSpan > 0.05) zoom = 14;
                        else zoom = 15;

                        console.log(`[VIEWPORT] Loaded: ${currentViewportName}, center: [${center[0].toFixed(4)}, ${center[1].toFixed(4)}], zoom: ${zoom}, bounds: [[${latMin.toFixed(4)}, ${lonMin.toFixed(4)}], [${latMax.toFixed(4)}, ${lonMax.toFixed(4)}]]`);
                    }
                }
            } catch (error) {
                console.warn('[VIEWPORT] Could not fetch viewport, using defaults:', error);
            }
        }

        // Create all three maps
        function createMaps() {
            // OSM Map
            maps.osm = L.map('map-osm', {
                center: center,
                zoom: zoom,
                zoomControl: true,
                minZoom: 6,
                maxZoom: 18
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(maps.osm);

            // Embedding Map (Tessera)
            maps.embedding = L.map('map-embedding', {
                center: center,
                zoom: zoom,
                zoomControl: true,
                minZoom: 6,
                maxZoom: 17
            });

            let embeddingLayer = L.tileLayer(`${TILE_SERVER}/tiles/${currentEmbeddingYear}/{z}/{x}/{y}.png`, {
                attribution: 'Tessera Embeddings',
                opacity: 1.0,
                maxZoom: 17,
                minZoom: 6,
                tileSize: 2048,
                zoomOffset: -3
            }).addTo(maps.embedding);

            // Clip embedding map to viewport bounds
            if (viewportBounds) {
                maps.embedding.setMaxBounds(viewportBounds);
                maps.embedding.options.maxBoundsViscosity = 1.0;  // Prevent bouncing when hitting edges
                console.log(`[MAPS] Embedding map clipped to viewport bounds: ${JSON.stringify(viewportBounds)}`);
            }

            // RGB Satellite Map
            maps.rgb = L.map('map-rgb', {
                center: center,
                zoom: zoom,
                zoomControl: true,
                minZoom: 6,
                maxZoom: 17
            });

            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Esri World Imagery',
                opacity: 1.0,
                maxZoom: 18,
                minZoom: 6
            }).addTo(maps.rgb);

            // Clip RGB satellite map to viewport bounds
            if (viewportBounds) {
                maps.rgb.setMaxBounds(viewportBounds);
                maps.rgb.options.maxBoundsViscosity = 1.0;  // Prevent bouncing when hitting edges
                console.log(`[MAPS] RGB satellite map clipped to viewport bounds`);
            }

            // Add click handlers
            Object.keys(maps).forEach(panel => {
                maps[panel].on('click', function(e) {
                    console.log(`[CLICK] Panel: ${panel}, labelingMode: ${labelingMode}, lat: ${e.latlng.lat}, lng: ${e.latlng.lng}`);

                    // Disable labeling on OSM panel
                    if (panel === 'osm') {
                        console.log('[CLICK] Labeling disabled on OSM panel');
                        return;
                    }

                    // If on embedding panel and in labeling mode, extract embedding and label it
                    if (panel === 'embedding' && labelingMode) {
                        console.log('[CLICK] Routing to embeddings labeling handler');
                        extractAndLabelEmbedding(e.latlng.lat, e.latlng.lng);
                    } else if (panel === 'rgb') {
                        // Old behavior: add marker only for RGB panel
                        console.log(`[CLICK] Routing to marker handler for RGB panel`);
                        const label = document.getElementById('label-input')?.value || 'unlabeled';
                        addMarker(panel, e.latlng.lat, e.latlng.lng, label);
                    }
                });
            });

            // Synchronize maps
            syncMaps();

            return embeddingLayer;
        }

        // Synchronize all maps
        function syncMaps() {
            // Use OSM as reference map
            const refMap = maps.osm;

            refMap.on('zoomend moveend', function() {
                const refCenter = refMap.getCenter();
                const refZoom = refMap.getZoom();

                Object.keys(maps).forEach(panel => {
                    if (panel !== 'osm') {
                        maps[panel].setView(refCenter, refZoom, {animate: false});
                    }
                });
            });
        }

        // Add marker
        function addMarker(panel, lat, lon, label) {
            const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;

            // Check if marker already exists (remove it)
            if (markers[panel][key]) {
                removeMarker(panel, lat, lon);
                return;
            }

            // Create marker
            const marker = L.marker([lat, lon], {
                title: label
            }).addTo(maps[panel]);

            marker.bindPopup(`<div class="marker-popup">${label}</div>`);

            // Store marker
            markers[panel][key] = marker;
            labels[panel].push([lat, lon, label]);

            updateLabelCount();
            console.log(`Added '${label}' at (${lat.toFixed(4)}, ${lon.toFixed(4)}) on ${panel} panel`);
        }

        // Remove marker
        function removeMarker(panel, lat, lon) {
            const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;

            if (markers[panel][key]) {
                maps[panel].removeLayer(markers[panel][key]);
                delete markers[panel][key];

                // Remove from labels
                labels[panel] = labels[panel].filter(
                    ([la, lo]) => Math.abs(la - lat) > 0.00001 || Math.abs(lo - lon) > 0.00001
                );

                updateLabelCount();
                console.log(`Removed marker at (${lat.toFixed(4)}, ${lon.toFixed(4)}) from ${panel} panel`);
            }
        }

        // Helper function to get viewport-specific localStorage key
        function getLabelsStorageKey() {
            const viewportId = currentViewportName || 'bangalore';
            return `${viewportId}_labels_3panel`;
        }

        // Update label count
        function updateLabelCount() {
            const oldTotal = Object.values(labels).reduce((sum, arr) => sum + arr.length, 0);
            const newTotal = Object.values(embeddingLabels).reduce((sum, arr) => sum + arr.length, 0);
            const total = oldTotal + newTotal;
            document.getElementById('label-count').textContent = `Labels: ${total}`;
        }

        // Save labels to localStorage
        function saveLabels() {
            const saveData = {
                // Old system: markers on maps
                labels: labels,
                embeddingYear: currentEmbeddingYear,
                // New system: embeddings for similarity search
                definedLabels: definedLabels,
                embeddingLabels: embeddingLabels,
                labelColors: labelColors
            };
            localStorage.setItem(getLabelsStorageKey(), JSON.stringify(saveData));
            const oldTotal = Object.values(labels).reduce((sum, arr) => sum + arr.length, 0);
            const newTotal = Object.values(embeddingLabels).reduce((sum, arr) => sum + arr.length, 0);
            console.log(`✓ Saved to ${getLabelsStorageKey()}: ${oldTotal} markers + ${newTotal} embeddings with colors`);
        }

        // Load labels from localStorage
        function loadLabels() {
            const storageKey = getLabelsStorageKey();
            let stored = localStorage.getItem(storageKey);

            // Fallback to old Bangalore key for backwards compatibility
            if (!stored && storageKey !== 'bangalore_labels_3panel') {
                stored = localStorage.getItem('bangalore_labels_3panel');
                if (stored) {
                    console.log('[BACKWARDS COMPATIBILITY] Found old Bangalore labels, will save to new viewport-specific key');
                }
            }
            if (stored) {
                try {
                    const saveData = JSON.parse(stored);

                    // Restore old marker system
                    if (saveData.labels) {
                        Object.keys(saveData.labels).forEach(panel => {
                            saveData.labels[panel].forEach(([lat, lon, label]) => {
                                addMarker(panel, lat, lon, label);
                            });
                        });
                        const oldCount = Object.values(saveData.labels).reduce((sum, arr) => sum + arr.length, 0);
                        console.log(`✓ Loaded ${oldCount} markers`);
                    }

                    // Restore new embedding labels system
                    if (saveData.definedLabels && saveData.embeddingLabels) {
                        definedLabels = saveData.definedLabels;
                        embeddingLabels = saveData.embeddingLabels;
                        if (saveData.labelColors) {
                            labelColors = saveData.labelColors;
                        }
                        updateLabelDropdown();
                        updateLabelCount();
                        const newCount = Object.values(embeddingLabels).reduce((sum, arr) => sum + arr.length, 0);
                        console.log(`✓ Loaded ${newCount} embeddings for ${definedLabels.length} labels with colors`);
                    }
                } catch (error) {
                    console.error('Error loading labels:', error);
                }
            }
        }

        // Clear all labels
        function clearAllLabels() {
            if (!confirm('Clear all labels?')) return;

            Object.keys(markers).forEach(panel => {
                Object.values(markers[panel]).forEach(marker => {
                    maps[panel].removeLayer(marker);
                });
                markers[panel] = {};
                labels[panel] = [];
            });

            updateLabelCount();
            console.log('Cleared all labels');
        }

        // Export labels to JSON
        function exportLabels() {
            const exportData = {
                embeddingYear: currentEmbeddingYear,
                labels: labels,
                timestamp: new Date().toISOString()
            };
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `bangalore_labels_${currentEmbeddingYear}_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            console.log('Exported labels to JSON file');
        }

        // =====================================================================
        // EMBEDDING LABELING SYSTEM
        // =====================================================================

        // Label management
        let definedLabels = [];  // List of all defined labels
        let embeddingLabels = {}; // {label: [[128-dim vector], [128-dim vector], ...]}
        let labelColors = {};    // {label: "#FF0000", ...}
        let labelingMode = false;
        let labelPixels = {}; // {key: {label: 'road', coordinate: {lat, lon}}} for visualization

        // Similarity search tracking
        let similarPixels = {};          // {key: {label, coordinate, embedding, distance, rectangle, marker}}
        let isSimilaritySearchActive = false;
        let activeSearchLabel = null;

        // Create a new label
        function createLabelDialog() {
            const labelName = prompt('Enter new label name (e.g., "road", "building", "tree"):');
            if (labelName && labelName.trim()) {
                const label = labelName.trim();
                if (definedLabels.includes(label)) {
                    alert(`Label "${label}" already exists!`);
                    return;
                }

                // Default colors for common labels
                const defaultColors = {
                    'road': '#FF6B6B',
                    'building': '#4ECDC4',
                    'tree': '#45B7D1',
                    'water': '#96CEB4',
                    'grass': '#FFEAA7',
                    'car': '#DDA15E',
                    'person': '#BC6C25'
                };

                const defaultColor = defaultColors[label] || '#' + Math.floor(Math.random()*16777215).toString(16);

                // Simple color picker using prompt with color preview
                showColorPickerModal(label, defaultColor);
            }
        }

        function showColorPickerModal(label, defaultColor) {
            // Create modal backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'color-picker-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create modal dialog
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                font-family: Arial, sans-serif;
                max-width: 400px;
                width: 90%;
            `;

            modal.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">Select color for "${label}"</h3>

                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                        <label style="font-weight: bold; margin: 0;">Color:</label>
                        <input type="color" id="label-color-picker" value="${defaultColor}" style="width: 60px; height: 50px; cursor: pointer; border: 2px solid #ddd; border-radius: 6px;">
                        <div id="color-preview" style="display: inline-block; width: 60px; height: 50px; background: ${defaultColor}; border: 2px solid #999; border-radius: 6px;"></div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="document.getElementById('color-picker-backdrop').remove();" style="padding: 10px 20px; background: #ddd; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Cancel</button>
                        <button onclick="confirmLabelColorSelection('${label}');" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Create Label</button>
                    </div>
                </div>
            `;

            backdrop.appendChild(modal);
            document.body.appendChild(backdrop);

            // Live preview color picker
            const colorPicker = document.getElementById('label-color-picker');
            const preview = document.getElementById('color-preview');
            colorPicker.addEventListener('input', (e) => {
                preview.style.background = e.target.value;
            });

            // Focus color picker
            colorPicker.focus();
        }

        function confirmLabelColorSelection(label) {
            const selectedColor = document.getElementById('label-color-picker').value;

            if (definedLabels.includes(label)) {
                alert(`Label "${label}" already exists!`);
                return;
            }

            definedLabels.push(label);
            definedLabels.sort();
            embeddingLabels[label] = [];
            labelColors[label] = selectedColor;

            // Close modal
            const backdrop = document.getElementById('color-picker-backdrop');
            if (backdrop) backdrop.remove();

            // Update UI
            updateLabelDropdown();
            saveLabels();
            console.log(`Created label: "${label}" with color ${selectedColor}`);
        }

        // Update the active label dropdown
        function updateLabelDropdown() {
            console.log('[DROPDOWN] Updating dropdown, definedLabels:', definedLabels);
            const select = document.getElementById('active-label');
            if (!select) {
                console.error('[DROPDOWN] ERROR: Could not find element with id="active-label"');
                return;
            }
            console.log('[DROPDOWN] Found select element:', select);

            select.innerHTML = '';
            if (definedLabels.length === 0) {
                console.log('[DROPDOWN] No labels, showing placeholder');
                select.innerHTML = '<option value="">No labels yet</option>';
                select.disabled = true;
            } else {
                console.log('[DROPDOWN] Adding', definedLabels.length, 'labels to dropdown');
                definedLabels.forEach(label => {
                    const option = document.createElement('option');
                    option.value = label;
                    option.textContent = label;
                    select.appendChild(option);
                    console.log('[DROPDOWN] Added option:', label);
                });
                select.value = definedLabels[0];
                select.disabled = false;
                console.log('[DROPDOWN] Set initial value to:', definedLabels[0]);
            }
            console.log('[DROPDOWN] Dropdown update complete. Current options:', select.innerHTML);
        }

        // Start labeling mode
        function startLabeling() {
            if (definedLabels.length === 0) {
                alert('Please create at least one label first!');
                return;
            }
            labelingMode = true;
            document.getElementById('start-label-btn').style.display = 'none';
            document.getElementById('stop-label-btn').style.display = 'block';
            document.getElementById('map-embedding').style.cursor = 'crosshair';
            console.log('Labeling mode: ON');
        }

        // Stop labeling mode
        function stopLabeling() {
            labelingMode = false;
            document.getElementById('start-label-btn').style.display = 'block';
            document.getElementById('stop-label-btn').style.display = 'none';
            document.getElementById('map-embedding').style.cursor = 'grab';
            console.log('Labeling mode: OFF');
        }

        // Extract embedding and associate with label
        async function extractAndLabelEmbedding(lat, lon) {
            console.log(`[LABELING] Click at (${lat.toFixed(6)}, ${lon.toFixed(6)}), labelingMode=${labelingMode}`);

            if (!labelingMode) {
                console.log('[LABELING] Labeling mode is OFF, ignoring click');
                return;
            }

            const activeLabel = document.getElementById('active-label').value;
            console.log(`[LABELING] Active label: "${activeLabel}"`);

            if (!activeLabel) {
                console.error('[LABELING] No active label selected!');
                alert('Please select an active label!');
                return;
            }

            try {
                console.log(`[LABELING] Calling API to extract embedding at (${lat}, ${lon})...`);

                // Call backend API to extract embedding
                const response = await fetch('/api/embeddings/extract', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat, lon })
                });

                console.log(`[LABELING] API response status: ${response.status}`);

                const data = await response.json();
                console.log(`[LABELING] API response:`, data);

                if (!data.success) {
                    console.error(`[LABELING] API error: ${data.error}`);
                    alert(`Error extracting embedding: ${data.error}`);
                    return;
                }

                console.log(`[LABELING] Got embedding with ${data.embedding.length} dimensions`);
                console.log(`[LABELING] Embedding (first 10): [${data.embedding.slice(0, 10).map(v => v.toFixed(2)).join(', ')}]`);
                console.log(`[LABELING] Embedding range: [${Math.min(...data.embedding).toFixed(2)}, ${Math.max(...data.embedding).toFixed(2)}]`);
                console.log(`[LABELING] Pixel: (${data.pixel.x}, ${data.pixel.y})`);

                // Store embedding with label
                embeddingLabels[activeLabel].push(data.embedding);
                console.log(`[LABELING] Now have ${embeddingLabels[activeLabel].length} embeddings for label "${activeLabel}"`);

                // Track pixel for visualization
                const key = `${data.pixel.x},${data.pixel.y}`;
                labelPixels[key] = {
                    label: activeLabel,
                    coordinate: {lat, lon},
                    embedding: data.embedding,
                    color: getColorForLabel(activeLabel)
                };

                // Update visualization (key already defined above)
                highlightLabeledPixel(lat, lon, activeLabel, key);

                // Update label count
                updateLabelCount();

                console.log(`✓ [LABELING] Successfully labeled pixel with "${activeLabel}" - stored embedding`);
            } catch (error) {
                console.error('[LABELING] Error extracting embedding:', error);
                alert('Error extracting embedding. Check console for details.');
            }
        }

        // Get a color for a label (for visualization)
        function getColorForLabel(label) {
            // Use user-selected color if available
            if (labelColors[label]) {
                return labelColors[label];
            }

            // Fallback to predefined colors
            const colors = {
                'road': '#FF6B6B',
                'building': '#4ECDC4',
                'tree': '#45B7D1',
                'water': '#96CEB4',
                'grass': '#FFEAA7',
                'car': '#DDA15E',
                'person': '#BC6C25'
            };
            if (colors[label]) return colors[label];

            // Generate consistent color from label name as last resort
            let hash = 0;
            for (let i = 0; i < label.length; i++) {
                hash = label.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = '#' + (Math.abs(hash) % 0xFFFFFF).toString(16).padStart(6, '0');
            return color;
        }

        // Invert RGB color: (R, G, B) -> (255-R, 255-G, 255-B)
        function invertColor(hexColor) {
            // Remove # if present
            const color = hexColor.replace('#', '');
            // Parse hex to RGB
            const r = parseInt(color.substr(0, 2), 16);
            const g = parseInt(color.substr(2, 2), 16);
            const b = parseInt(color.substr(4, 2), 16);
            // Invert: 255 - value
            const invR = (255 - r).toString(16).padStart(2, '0');
            const invG = (255 - g).toString(16).padStart(2, '0');
            const invB = (255 - b).toString(16).padStart(2, '0');
            return '#' + invR + invG + invB;
        }

        // Calculate pixel size in degrees (10m x 10m)
        function calculatePixelBounds(lat, lon) {
            // Each pixel is 10m x 10m
            // 1 degree latitude = ~111.32 km = 111320 m
            // 1 degree longitude = ~111.32 * cos(latitude) km at that latitude
            const latPerMeter = 1 / 111320;
            const lonPerMeter = 1 / (111320 * Math.cos(lat * Math.PI / 180));

            const pixelSizeMeters = 10;  // 10m x 10m pixel
            const latOffset = pixelSizeMeters * latPerMeter / 2;
            const lonOffset = pixelSizeMeters * lonPerMeter / 2;

            return [
                [lat - latOffset, lon - lonOffset],  // Southwest
                [lat + latOffset, lon + lonOffset]   // Northeast
            ];
        }

        // Delete a labeled pixel
        function deleteLabeledPixel(key, pixelData) {
            // Confirm deletion
            if (!confirm(`Delete labeled pixel "${pixelData.label}"?`)) {
                return;
            }

            // Find and remove the embedding from the label's embedding array
            const embeddingIndex = embeddingLabels[pixelData.label].findIndex(emb =>
                JSON.stringify(emb) === JSON.stringify(pixelData.embedding)
            );

            if (embeddingIndex !== -1) {
                embeddingLabels[pixelData.label].splice(embeddingIndex, 1);
                console.log(`[DELETE] Removed embedding from label "${pixelData.label}"`);
            }

            // Remove the visual elements (rectangle and marker)
            if (pixelData.rectangle) {
                maps.embedding.removeLayer(pixelData.rectangle);
            }
            if (pixelData.marker) {
                maps.embedding.removeLayer(pixelData.marker);
            }

            // Remove from tracking
            delete labelPixels[key];

            // Update label count
            updateLabelCount();

            console.log(`[DELETE] Deleted labeled pixel at key "${key}"`);
        }

        // Highlight labeled pixel on embedding map as rectangle with zoom-responsive circle
        function highlightLabeledPixel(lat, lon, label, key) {
            const labelColor = getColorForLabel(label);
            const bounds = calculatePixelBounds(lat, lon);

            const rectangle = L.rectangle(bounds, {
                color: labelColor,  // Label color outline
                weight: 1,  // Thin outline
                opacity: 1.0,
                fill: true,
                fillColor: labelColor,  // Label color fill
                fillOpacity: 0.8,  // Solid color
                className: 'labeled-pixel'
            }).addTo(maps.embedding);

            // Add a zoom-responsive circle around the pixel for visibility at all zoom levels
            const circle = L.circle([lat, lon], {
                radius: 40,  // 40 meters - visible even when zoomed out
                color: labelColor,
                weight: 2,
                opacity: 0.7,
                fill: true,
                fillColor: labelColor,
                fillOpacity: 0.3,
                className: 'labeled-pixel-circle'
            }).addTo(maps.embedding);

            // Update circle visibility based on zoom level
            function updateCircleVisibility() {
                const zoom = maps.embedding.getZoom();
                // Show circle when zoomed out (zoom < 14), hide when zoomed in
                circle.setStyle({
                    opacity: zoom < 14 ? 0.7 : 0,
                    fillOpacity: zoom < 14 ? 0.3 : 0
                });
            }

            // Update on zoom change
            maps.embedding.on('zoomend', updateCircleVisibility);
            updateCircleVisibility();  // Initial check

            // Show label on hover
            const popupContent = `<div style="font-weight: 600; color: ${labelColor}; font-size: 12px;">${label}</div>`;
            rectangle.bindPopup(popupContent);
            circle.bindPopup(popupContent);

            rectangle.on('mouseover', function() {
                this.openPopup();
                this.setStyle({fillOpacity: 0.95, weight: 2});  // Brighten on hover
            });
            rectangle.on('mouseout', function() {
                this.closePopup();
                this.setStyle({fillOpacity: 0.8, weight: 1});  // Reset
            });

            circle.on('mouseover', function() {
                this.openPopup();
                this.setStyle({fillOpacity: 0.6, weight: 3});  // Brighten on hover
            });
            circle.on('mouseout', function() {
                this.closePopup();
                updateCircleVisibility();  // Reset to zoom-dependent visibility
            });

            // Click to delete (on either shape)
            rectangle.on('click', function() {
                deleteLabeledPixel(key, labelPixels[key]);
            });
            circle.on('click', function() {
                deleteLabeledPixel(key, labelPixels[key]);
            });

            // Add a pin/marker at the center of the labeled pixel for better visibility
            const markerIcon = L.divIcon({
                html: `<div style="
                    width: 12px;
                    height: 12px;
                    background: ${labelColor};
                    border: 1px solid rgba(0,0,0,0.3);
                    border-radius: 50%;
                    box-shadow: 0 0 6px rgba(0,0,0,0.4);
                "></div>`,
                iconSize: [12, 12],
                className: 'labeled-pixel-marker'
            });

            const marker = L.marker([lat, lon], {
                icon: markerIcon,
                title: label
            }).addTo(maps.embedding);

            // Bind popup to marker
            marker.bindPopup(popupContent);

            // Hover behavior for marker
            marker.on('mouseover', function() {
                this.openPopup();
            });
            marker.on('mouseout', function() {
                this.closePopup();
            });

            // Click to delete
            marker.on('click', function(e) {
                L.DomEvent.stopPropagation(e);  // Prevent map click
                deleteLabeledPixel(key, labelPixels[key]);
            });

            // Store references to visual elements in labelPixels for deletion
            labelPixels[key].rectangle = rectangle;
            labelPixels[key].marker = marker;
        }

        // Update label count display
        function updateLabelCount() {
            let totalEmbeddings = 0;
            Object.values(embeddingLabels).forEach(embs => {
                totalEmbeddings += embs.length;
            });
            document.getElementById('label-count').textContent =
                `Labels: ${definedLabels.length} | Embeddings: ${totalEmbeddings}`;
        }

        // Export labels to JSON file
        function exportLabelsJSON() {
            if (definedLabels.length === 0 || Object.values(embeddingLabels).every(e => e.length === 0)) {
                alert('No labeled embeddings to export!');
                return;
            }

            // Build export data sorted by label name
            const exportData = definedLabels.map(label => ({
                label: label,
                embedding: embeddingLabels[label]
            }));

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `embedding_labels_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log(`✓ Exported ${definedLabels.length} labels with ${Object.values(embeddingLabels).reduce((sum, e) => sum + e.length, 0)} embeddings`);
        }

        // Import labels from JSON file
        function importLabelsJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    if (!Array.isArray(importData)) {
                        alert('Invalid file format. Expected array of label objects.');
                        return;
                    }

                    let totalEmbeddings = 0;

                    console.log('[IMPORT] Starting import process...');
                    console.log('[IMPORT] definedLabels before:', definedLabels);

                    // Import each label
                    importData.forEach(item => {
                        const label = item.label;
                        const embeddings = item.embedding || [];

                        // Create label if it doesn't exist
                        if (!definedLabels.includes(label)) {
                            definedLabels.push(label);
                            embeddingLabels[label] = [];
                            console.log(`[IMPORT] Created new label: "${label}"`);
                        }

                        // Add embeddings
                        embeddingLabels[label].push(...embeddings);
                        totalEmbeddings += embeddings.length;

                        console.log(`[IMPORT] Added ${embeddings.length} embeddings to "${label}"`);
                    });

                    console.log('[IMPORT] definedLabels after import:', definedLabels);
                    console.log('[IMPORT] embeddingLabels:', embeddingLabels);

                    // Sort labels alphabetically
                    definedLabels.sort();
                    console.log('[IMPORT] definedLabels after sort:', definedLabels);

                    // Update label dropdown using the standard function
                    console.log('[IMPORT] Calling updateLabelDropdown()...');
                    updateLabelDropdown();
                    console.log('[IMPORT] updateLabelDropdown() completed');

                    // Update label count to show imported embeddings
                    updateLabelCount();

                    // Save to localStorage
                    saveLabels();

                    alert(`✓ Successfully imported ${definedLabels.length} labels with ${totalEmbeddings} embeddings!`);
                    console.log(`✓ Imported ${definedLabels.length} labels with ${totalEmbeddings} total embeddings`);

                } catch (error) {
                    alert(`Error importing labels: ${error.message}`);
                    console.error('Import error:', error);
                }

                // Reset file input
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // =====================================================================
        // SIMILARITY SEARCH FUNCTIONS
        // =====================================================================

        // Update threshold display when slider changes
        function updateThresholdDisplay() {
            const slider = document.getElementById('similarity-threshold');
            const display = document.getElementById('threshold-display');
            // Map slider 0-100 to threshold 0.0-15.0 (for float32 embeddings in native range)
            // Embeddings are float32 with range ~[-13.64, 17.22], so L2 distances naturally range from 0-15+
            // This gives: 0%=exact match, 33%=moderate similarity (~5.0), 67%=relaxed (~10.0), 100%=very broad (~15.0)
            const value = (parseInt(slider.value) / 100) * 15.0;
            display.textContent = value.toFixed(2);
        }

        // Calculate average embedding from array of embeddings
        function calculateAverageEmbedding(embeddings) {
            if (embeddings.length === 0) return null;

            const dim = embeddings[0].length;
            const avgEmb = new Array(dim).fill(0);

            // Sum all embeddings
            for (let emb of embeddings) {
                for (let i = 0; i < dim; i++) {
                    avgEmb[i] += emb[i];
                }
            }

            // Divide by count - keep as float32, don't clamp!
            // Embeddings are float32 values (e.g., -2.5, 5.8, 1.3), not uint8 (0-255)
            for (let i = 0; i < dim; i++) {
                avgEmb[i] = avgEmb[i] / embeddings.length;
            }

            console.log(`[SIMILARITY] Calculated average embedding: ${dim} dims, range [${Math.min(...avgEmb).toFixed(2)}, ${Math.max(...avgEmb).toFixed(2)}]`);
            return avgEmb;
        }

        // Find similar pixels using ALL labeled embeddings (not average)
        async function findSimilarPixels() {
            const activeLabel = document.getElementById('active-label').value;

            if (!activeLabel) {
                alert('Please select an active label first!');
                return;
            }

            // Check if label has any embeddings
            if (!embeddingLabels[activeLabel] || embeddingLabels[activeLabel].length === 0) {
                alert(`Label "${activeLabel}" has no manually labeled pixels yet. Please label at least one pixel first.`);
                return;
            }

            // Clear any previous similarity search
            clearSimilarPixels();

            const labeledEmbeddings = embeddingLabels[activeLabel];
            console.log(`[SIMILARITY] Searching for pixels similar to ANY of ${labeledEmbeddings.length} labeled "${activeLabel}" embeddings`);

            // Get threshold
            const threshold = parseFloat(document.getElementById('threshold-display').textContent);
            console.log(`[SIMILARITY] Threshold: ${threshold}`);

            // Use tile_aligned viewport for similarity search
            try {
                const viewportId = 'tile_aligned';
                console.log(`[SIMILARITY] Viewport: ${viewportId}`);

                // Show loading state
                document.getElementById('find-similar-btn').disabled = true;
                document.getElementById('find-similar-btn').textContent = `Searching (0/${labeledEmbeddings.length})...`;

                const allMatches = new Map(); // Use map to deduplicate by pixel key
                let completed = 0;

                // Search for each labeled embedding individually
                for (let i = 0; i < labeledEmbeddings.length; i++) {
                    const embedding = labeledEmbeddings[i];
                    completed++;

                    // Update progress
                    document.getElementById('find-similar-btn').textContent = `Searching (${completed}/${labeledEmbeddings.length})...`;

                    console.log(`[SIMILARITY] Searching embedding ${i + 1}/${labeledEmbeddings.length}...`);

                    const requestBody = {
                        embedding: embedding,
                        threshold: threshold,
                        viewport_id: viewportId
                    };

                    const response = await fetch('/api/embeddings/search-similar', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    const data = await response.json();

                    if (!data.success) {
                        console.warn(`[SIMILARITY] Search ${i + 1} failed: ${data.error}`);
                        continue;
                    }

                    console.log(`[SIMILARITY] Search ${i + 1} found ${data.matches.length} matches`);

                    // Add matches to map, using pixel coords as key to deduplicate
                    for (const match of data.matches) {
                        const key = `${match.pixel.x},${match.pixel.y}`;
                        // Keep the closest match (smallest distance)
                        if (!allMatches.has(key) || match.distance < allMatches.get(key).distance) {
                            allMatches.set(key, match);
                        }
                    }
                }

                // Convert map to array
                const uniqueMatches = Array.from(allMatches.values());
                console.log(`[SIMILARITY] Found ${uniqueMatches.length} unique matches across all ${labeledEmbeddings.length} embeddings`);

                // Visualize results in preview mode
                visualizeSimilarPixels(uniqueMatches, activeLabel);

                // Update UI
                activeSearchLabel = activeLabel;
                isSimilaritySearchActive = true;
                document.getElementById('commit-similar-btn').style.display = 'block';
                document.getElementById('clear-similar-btn').style.display = 'block';
                document.getElementById('similar-count').textContent = uniqueMatches.length;

            } catch (error) {
                console.error('[SIMILARITY] Error:', error);
                alert('Error finding similar pixels. Check console for details.');
            } finally {
                document.getElementById('find-similar-btn').disabled = false;
                document.getElementById('find-similar-btn').textContent = 'Find Similar';
            }
        }

        // Visualize similar pixels in preview mode (with circles for better visibility)
        function visualizeSimilarPixels(matches, label) {
            console.log(`[VISUALIZE] Starting visualization with ${matches.length} matches for label "${label}"`);
            const labelColor = getColorForLabel(label);
            console.log(`[VISUALIZE] Label color: ${labelColor}`);

            let visualizedCount = 0;
            let skippedCount = 0;

            matches.forEach(match => {
                const lat = match.lat;
                const lon = match.lon;
                const key = `${match.pixel.x},${match.pixel.y}`;

                // Check if already labeled (committed)
                const isAlreadyLabeled = labelPixels[key];

                if (isAlreadyLabeled) {
                    skippedCount++;
                    console.log(`[VISUALIZE] Skipping already-labeled pixel at (${lat.toFixed(6)}, ${lon.toFixed(6)}) [${isAlreadyLabeled.label}]`);
                    // Don't return - continue to visualize it anyway for feedback
                } else {
                    console.log(`[VISUALIZE] Adding circle at (${lat.toFixed(6)}, ${lon.toFixed(6)}), distance=${match.distance.toFixed(4)}`);
                }

                // Create colored rectangle overlay (10m x 10m pixel)
                const pixelSizeMeters = 10;
                const latPerMeter = 1 / 111000;  // Approximately
                const lonPerMeter = 1 / (111000 * Math.cos(lat * Math.PI / 180));

                const latOffset = (pixelSizeMeters * latPerMeter) / 2;
                const lonOffset = (pixelSizeMeters * lonPerMeter) / 2;

                const bounds = [
                    [lat - latOffset, lon - lonOffset],
                    [lat + latOffset, lon + lonOffset]
                ];

                const rectangle = L.rectangle(bounds, {
                    color: labelColor,
                    weight: 0,  // No border
                    fill: true,
                    fillColor: labelColor,
                    fillOpacity: 0.7,  // Solid fill with good visibility
                    className: 'similar-pixel-preview'
                }).addTo(maps.embedding);

                // Show label and distance on hover
                const popupContent = `<div style="font-weight: 600; color: ${labelColor}; font-size: 12px;">
                    ${label} (similar)<br/>
                    <span style="font-size: 10px;">Distance: ${match.distance.toFixed(3)}</span>
                </div>`;
                rectangle.bindPopup(popupContent);

                rectangle.on('mouseover', function() {
                    this.openPopup();
                    this.setStyle({fillOpacity: 0.9});
                });
                rectangle.on('mouseout', function() {
                    this.closePopup();
                    this.setStyle({fillOpacity: 0.7});
                });

                // Store in temporary similarPixels structure
                similarPixels[key] = {
                    label: label,
                    coordinate: {lat, lon},
                    embedding: null,  // Will use average when committing
                    distance: match.distance,
                    pixel: match.pixel,
                    rectangle: rectangle,
                    marker: null
                };

                visualizedCount++;
            });

            console.log(`[VISUALIZE] Complete! Visualized: ${visualizedCount}, Skipped (already labeled): ${skippedCount}`);
        }

        // Clear similar pixels preview (cancel search)
        function clearSimilarPixels() {
            if (Object.keys(similarPixels).length === 0) return;

            console.log(`[SIMILARITY] Clearing ${Object.keys(similarPixels).length} preview pixels`);

            // Remove all preview visualizations
            for (const [key, pixelData] of Object.entries(similarPixels)) {
                if (pixelData.rectangle) {
                    maps.embedding.removeLayer(pixelData.rectangle);
                }
                if (pixelData.marker) {
                    maps.embedding.removeLayer(pixelData.marker);
                }
            }

            similarPixels = {};
            isSimilaritySearchActive = false;
            activeSearchLabel = null;

            // Update UI
            document.getElementById('commit-similar-btn').style.display = 'none';
            document.getElementById('clear-similar-btn').style.display = 'none';
            document.getElementById('similar-count').textContent = '0';

            console.log('[SIMILARITY] Preview cleared');
        }

        // Commit similar pixels and apply intelligent relabeling
        async function commitSimilarPixels() {
            if (!isSimilaritySearchActive || Object.keys(similarPixels).length === 0) {
                alert('No similar pixels to commit!');
                return;
            }

            const activeLabel = activeSearchLabel;
            const pixelCount = Object.keys(similarPixels).length;

            if (!confirm(`Commit ${pixelCount} similar pixels to label "${activeLabel}" and relabel existing pixels?`)) {
                return;
            }

            console.log(`[SIMILARITY] Committing ${pixelCount} similar pixels to "${activeLabel}"`);

            try {
                // Get average embedding for the current label (before adding new pixels)
                const avgEmbedding = calculateAverageEmbedding(embeddingLabels[activeLabel]);

                // Step 1: Add similar pixels to embeddingLabels
                for (const [key, pixelData] of Object.entries(similarPixels)) {
                    embeddingLabels[activeLabel].push(avgEmbedding);
                }

                // Step 2: Visualize newly committed similar pixels with solid styling
                const newlyCommitted = [];
                for (const [key, pixelData] of Object.entries(similarPixels)) {
                    const lat = pixelData.coordinate.lat;
                    const lon = pixelData.coordinate.lon;

                    labelPixels[key] = {
                        label: activeLabel,
                        coordinate: {lat, lon},
                        embedding: avgEmbedding,
                        color: getColorForLabel(activeLabel)
                    };

                    // Remove preview rectangle
                    if (pixelData.rectangle) {
                        maps.embedding.removeLayer(pixelData.rectangle);
                    }

                    // Re-visualize with committed styling
                    highlightLabeledPixel(lat, lon, activeLabel, key);
                    newlyCommitted.push(key);
                }

                console.log(`[SIMILARITY] ✓ Visualized ${newlyCommitted.length} newly committed pixels`);

                // Step 3: Apply intelligent relabeling
                console.log(`[SIMILARITY] Starting intelligent relabeling...`);

                // Prepare data for relabeling endpoint
                const relabelRequest = {
                    label_embeddings: embeddingLabels,
                    labeled_pixels: {}
                };

                // Build labeled_pixels object for relabeling
                for (const [key, pixelData] of Object.entries(labelPixels)) {
                    relabelRequest.labeled_pixels[key] = {
                        label: pixelData.label,
                        embedding: pixelData.embedding,
                        lat: pixelData.coordinate.lat,
                        lon: pixelData.coordinate.lon
                    };
                }

                // Call relabeling endpoint
                const relabelResponse = await fetch('/api/embeddings/relabel-by-similarity', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(relabelRequest)
                });

                const relabelData = await relabelResponse.json();

                if (!relabelData.success) {
                    console.warn(`[SIMILARITY] Relabeling failed: ${relabelData.error}`);
                } else {
                    console.log(`[SIMILARITY] Relabeling complete: ${relabelData.stats.relabeled_pixels} relabeled, ${relabelData.stats.unchanged_pixels} unchanged`);

                    // Apply relabeling results
                    if (relabelData.relabeled && relabelData.relabeled.length > 0) {
                        console.log(`[SIMILARITY] Applying ${relabelData.relabeled.length} relabelings...`);

                        for (const relabel of relabelData.relabeled) {
                            const key = relabel.key;
                            const oldLabel = relabel.old_label;
                            const newLabel = relabel.new_label;
                            const oldDistance = relabel.old_distance;
                            const newDistance = relabel.new_distance;

                            console.log(`[RELABEL] ${key}: ${oldLabel} (${oldDistance.toFixed(4)}) → ${newLabel} (${newDistance.toFixed(4)})`);

                            // Update labelPixels
                            if (labelPixels[key]) {
                                // Remove old visualization
                                if (labelPixels[key].rectangle) {
                                    maps.embedding.removeLayer(labelPixels[key].rectangle);
                                }
                                if (labelPixels[key].marker) {
                                    maps.embedding.removeLayer(labelPixels[key].marker);
                                }

                                // Update label and color
                                labelPixels[key].label = newLabel;
                                labelPixels[key].color = getColorForLabel(newLabel);

                                // Re-visualize with new label's color
                                highlightLabeledPixel(relabel.lat, relabel.lon, newLabel, key);
                            }
                        }

                        // Show relabeling summary
                        let summary = `Successfully committed ${pixelCount} similar pixels!\n\nRelabeling Summary:\n`;
                        const relabelCounts = {};
                        for (const relabel of relabelData.relabeled) {
                            const transKey = `${relabel.old_label} → ${relabel.new_label}`;
                            relabelCounts[transKey] = (relabelCounts[transKey] || 0) + 1;
                        }
                        for (const [transition, count] of Object.entries(relabelCounts)) {
                            summary += `• ${count} pixel(s) relabeled: ${transition}\n`;
                        }
                        console.log(`[SIMILARITY] ${summary}`);
                        alert(summary);
                    } else {
                        alert(`Successfully committed ${pixelCount} similar pixels!\nNo existing pixels needed relabeling.`);
                    }
                }

            } catch (error) {
                console.error('[SIMILARITY] Error during commit/relabel:', error);
                alert('Error during commit/relabel. Check console for details.');
                return;
            }

            // Step 4: Clear UI
            similarPixels = {};
            isSimilaritySearchActive = false;
            activeSearchLabel = null;

            document.getElementById('commit-similar-btn').style.display = 'none';
            document.getElementById('clear-similar-btn').style.display = 'none';
            document.getElementById('similar-count').textContent = '0';
            updateLabelCount();

            console.log(`[SIMILARITY] ✓ Commit and relabel complete!`);
        }

        // Auto-clear preview when active label changes
        document.addEventListener('DOMContentLoaded', function() {
            const activeLabel = document.getElementById('active-label');
            if (activeLabel) {
                activeLabel.addEventListener('change', function() {
                    if (isSimilaritySearchActive) {
                        console.log('[SIMILARITY] Active label changed - clearing preview');
                        clearSimilarPixels();
                    }
                });
            }
        });

        // Initialize
        window.onload = async function() {
            // Load viewport info first (determines map center/zoom)
            await updateMapViewport();

            // Then create maps with correct viewport
            createMaps();
            loadLabels();
            updateThresholdDisplay();  // Initialize threshold display

            // Check tile server health
            fetch(`${TILE_SERVER}/health`)
                .then(resp => resp.json())
                .then(data => {
                    console.log('Tile server status:', data);
                })
                .catch(err => {
                    console.warn('Tile server not responding:', err);
                    alert('Warning: Tile server not responding. Make sure it is running on port 5125.');
                });
        };
    </script>
</body>
</html>
