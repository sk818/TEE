<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>TEE Viewer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        #controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #2a2a2a;
            padding: 12px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px 15px;
        }

        #controls h1 {
            font-size: 18px;
            font-weight: 600;
            margin-right: 10px;
        }

        /* Responsive header adjustments */
        @media (max-width: 1400px) {
            #controls {
                padding: 10px 15px;
                gap: 8px 12px;
            }
            #controls h1 {
                font-size: 16px;
            }
            #controls button,
            #controls select {
                padding: 6px 10px !important;
                font-size: 12px !important;
            }
            #controls label {
                font-size: 12px;
            }
        }

        @media (max-width: 1000px) {
            #controls {
                padding: 8px 10px;
                gap: 6px 10px;
            }
            #controls h1 {
                font-size: 14px;
                margin-right: 5px;
            }
            #controls button,
            #controls select {
                padding: 4px 8px !important;
                font-size: 11px !important;
            }
            /* Hide some text labels on narrow screens */
            #controls .hide-narrow {
                display: none;
            }
        }

        #controls label {
            font-size: 14px;
            margin-right: 5px;
        }

        #controls select,
        #controls input {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #fff;
            font-size: 14px;
        }

        #controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 0.2s;
        }

        .save-btn {
            background: #28a745;
            color: white;
        }

        .save-btn:hover {
            background: #218838;
        }

        .clear-btn {
            background: #dc3545;
            color: white;
        }

        .clear-btn:hover {
            background: #c82333;
        }

        .export-btn {
            background: #007bff;
            color: white;
        }

        .export-btn:hover {
            background: #0056b3;
        }

        #label-count {
            padding: 8px 12px;
            background: #333;
            border-radius: 4px;
            font-weight: 600;
        }

        @keyframes pulse-warning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .export-btn-highlight {
            background: #ff9800 !important;
            color: #000 !important;
            border-color: #e68a00 !important;
            font-weight: 700 !important;
        }

        .export-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            min-width: 170px;
            z-index: 1000;
            margin-top: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .export-dropdown-menu button {
            display: block;
            width: 100%;
            padding: 9px 14px;
            background: none;
            color: white;
            border: none;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        .export-dropdown-menu button:hover {
            background: #444;
        }
        .export-dropdown-menu button:not(:last-child) {
            border-bottom: 1px solid #444;
        }

        #map-container {
            position: fixed;
            top: 110px;
            left: 0;
            right: 0;
            bottom: 40px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            background: #1a1a1a;
            transition: grid-template-rows 0.3s ease;
        }

        /* 3-panel mode: hide bottom row */
        #map-container.three-panel {
            grid-template-rows: 1fr;
        }

        #map-container.three-panel .panel:nth-child(n+4) {
            display: none;
        }

        .panel {
            position: relative;
            background: #2a2a2a;
            min-width: 0;  /* Allow grid items to shrink below content width */
            overflow: hidden;  /* Prevent content from overflowing */
        }

        .panel-header {
            position: absolute;
            top: 10px;
            right: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .panel-header span {
            white-space: nowrap;
        }

        .panel-header select {
            flex-shrink: 0;
        }

        /* Responsive: smaller text and compact layout on narrow screens */
        @media (max-width: 1200px) {
            .panel-header {
                font-size: 12px;
                padding: 6px 10px;
                top: 5px;
                right: 10px;
                left: 10px;
            }
            .panel-header select {
                font-size: 11px !important;
                padding: 2px 4px !important;
            }
        }

        @media (max-width: 900px) {
            .panel-header {
                font-size: 11px;
                padding: 4px 8px;
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }
            .panel-header span {
                white-space: normal;
                word-break: break-word;
            }
        }

        .map {
            width: 100%;
            height: 100%;
            min-width: 0;  /* Allow shrinking */
            overflow: hidden;  /* Clip content that overflows during resize */
            cursor: crosshair;
        }

        /* Hand cursor when dragging/panning */
        .leaflet-dragging .map,
        .leaflet-dragging .leaflet-container {
            cursor: grabbing !important;
        }

        /* Also apply to Three.js canvas in Panel 4 */
        .map canvas {
            cursor: crosshair;
        }

        /* Crisp pixelated tiles for embedding panels (no blur at high zoom) */
        /* From Leaflet issue #5883 - comprehensive nearest-neighbor override */
        #map-embedding.leaflet-container .leaflet-tile-pane img,
        #map-embedding2.leaflet-container .leaflet-tile-pane img,
        #map-embedding .leaflet-tile,
        #map-embedding2 .leaflet-tile {
            max-width: none !important;
            image-rendering: optimizeSpeed !important;
            image-rendering: -moz-crisp-edges !important;
            image-rendering: -o-crisp-edges !important;
            image-rendering: -webkit-optimize-contrast !important;
            image-rendering: optimize-contrast !important;
            image-rendering: crisp-edges !important;
            image-rendering: pixelated !important;
            -ms-interpolation-mode: nearest-neighbor !important;
        }

        /* Ensure triangle markers appear above canvas layers */
        .triangle-marker {
            z-index: 1000 !important;
        }

        #status {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2a2a2a;
            padding: 10px 20px;
            font-size: 12px;
            color: #999;
            border-top: 1px solid #333;
        }

        .marker-popup {
            font-size: 14px;
            font-weight: bold;
        }

        /* Progress Modal */
        #progress-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        #progress-overlay.active {
            display: flex;
            pointer-events: auto;
        }

        #progress-modal {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        #progress-modal h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #fff;
        }

        #progress-message {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 15px;
            word-break: break-word;
        }

        #progress-file {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .progress-bar-container {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            height: 24px;
            overflow: hidden;
            margin-bottom: 12px;
            position: relative;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #17a2b8, #0d8fa3);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: white;
        }

        #progress-percent {
            font-size: 13px;
            color: #aaa;
            text-align: right;
            margin-bottom: 12px;
        }

        #progress-status {
            font-size: 12px;
            color: #17a2b8;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #progress-status.complete {
            color: #28a745;
        }

        #progress-status.error {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1 id="viewer-title">TEE Viewer</h1>

        <!-- Back to Viewports -->
        <button style="background: #6c757d; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;" onclick="window.location.href = '/'">‚Üê Back</button>

        <!-- User / Logout -->
        <div id="userInfo" style="display:none; margin-left:auto; align-items:center; gap:8px; font-size:13px;">
            <span id="userName" style="opacity:0.7;"></span>
            <button style="background:#555; color:white; padding:6px 12px; border:none; border-radius:4px; cursor:pointer; font-size:12px;" onclick="showChangePassword()">Password</button>
            <button style="background:#6c757d; color:white; padding:6px 12px; border:none; border-radius:4px; cursor:pointer; font-size:12px;" onclick="doLogout()">Logout</button>
        </div>
        <button id="loginBtn" style="display:none; margin-left:auto; background:#667eea; color:white; padding:6px 14px; border:none; border-radius:4px; cursor:pointer; font-size:12px; font-weight:600;" onclick="window.location.href='/login.html'">Login</button>

        <!-- Similarity Search Controls -->
        <div style="display: flex; gap: 10px; align-items: center; margin-left: 20px; border-left: 1px solid #444; padding-left: 20px;">
            <label style="margin: 0;">Similarity:</label>
            <input
                type="range"
                id="similarity-threshold"
                min="0"
                max="35"
                value="12"
                style="width: 120px; cursor: pointer;"
                oninput="updateThresholdDisplay()"
            />
            <span id="threshold-display" style="background: #333; padding: 4px 8px; border-radius: 3px; font-size: 13px; min-width: 40px; text-align: center;">12.00</span>

        </div>

        <!-- Label Controls (shown when FAISS index is ready) -->
        <div id="label-controls-bar" style="display: none; gap: 10px; align-items: center; margin-left: 20px; border-left: 1px solid #444; padding-left: 20px;">
            <button id="save-label-btn" style="padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 13px; white-space: nowrap;" disabled>
                üíæ Save as Label
            </button>
            <div style="color: white; background: #333; padding: 4px 8px; border-radius: 3px; font-weight: 600; font-size: 13px;">Labels: <span id="label-count">0</span></div>
            <button id="labels-toggle-btn" style="padding: 8px 12px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 13px; white-space: nowrap;">
                üìã View Labels
            </button>
            <button id="toggle-all-overlays" style="padding: 8px 12px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; white-space: nowrap;">
                üëÅ Toggle Overlays
            </button>
            <div style="position: relative; display: inline-block;">
                <button id="export-dropdown-btn" style="padding: 8px 12px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 13px; white-space: nowrap;">
                    Export &#9662;
                </button>
                <div id="export-dropdown-menu" class="export-dropdown-menu">
                    <button id="export-labels-json-btn">Labels (JSON)</button>
                    <button id="export-labels-geojson-btn">Labels (GeoJSON)</button>
                    <button id="export-map-btn">Map (JPG)</button>
                </div>
            </div>
            <span id="unsaved-labels-warning" style="display: none; background: #ff9800; color: #000; padding: 4px 10px; border-radius: 3px; font-weight: 700; font-size: 12px; white-space: nowrap; animation: pulse-warning 1.5s ease-in-out 3;">‚ö† Unsaved labels ‚Äî export to avoid losing work</span>
            <button id="import-labels-btn" style="padding: 8px 12px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 13px; white-space: nowrap;">
                Import
            </button>
            <input type="file" id="import-labels-file" accept=".json" style="display: none;">
            <button id="status-btn" style="padding: 8px 12px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 13px; white-space: nowrap;">
                ‚ÑπÔ∏è Status
            </button>
        </div>

        <!-- Panel Layout Selector -->
        <div style="display: flex; gap: 10px; align-items: center; margin-left: 20px; border-left: 1px solid #444; padding-left: 20px;">
            <label style="margin: 0; font-size: 13px;">Layout:</label>
            <select id="panel-layout-select" onchange="setPanelLayout(this.value)" style="padding: 6px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; font-size: 13px; cursor: pointer;">
                <option value="3">3 Panels</option>
                <option value="6">6 Panels</option>
            </select>
        </div>

        <!-- Lat/Lon Coordinates -->
        <div id="header-coords" style="margin-left: auto; font-family: monospace; font-size: 13px; color: #aaa; white-space: nowrap;"></div>

        <!-- Help Button -->
        <button id="help-btn" style="padding: 8px 12px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 13px; white-space: nowrap; margin-left: 10px;">? Help</button>

        <!-- Help Popup -->
        <div id="help-popup" style="position: absolute; top: 100%; right: 10px; width: 340px; background: rgba(255,255,255,0.98); backdrop-filter: blur(10px); border-radius: 8px; padding: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 999; font-size: 13px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div style="font-weight: 600; font-size: 14px; color: #333;">Quick Reference</div>
                <button id="help-close-btn" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 0; width: 20px; height: 20px; color: #666;">&#10005;</button>
            </div>
            <div style="line-height: 1.8; color: #444;">
                <div><b>Left-click</b> anywhere to locate a point</div>
                <div><b>Left-click drag</b> to pan the map</div>
                <div><b>Scroll</b> to zoom in/out</div>
                <div><b>Double-click</b> for similarity search. Use similarity slider to change selected region and click <b>Save as Label</b> to label it.</div>
                <div><b>Right-click drag</b> to rotate (PCA/UMAP pane)</div>
                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">Use <b>Export</b> / <b>Import</b> to save labels to your desktop or load them from a local file.</div>
            </div>
        </div>

        <!-- Status Popup -->
        <div id="status-popup" style="position: absolute; top: 100%; right: 10px; width: 320px; background: rgba(255,255,255,0.98); backdrop-filter: blur(10px); border-radius: 8px; padding: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 999; font-size: 12px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div style="font-weight: 600; font-size: 14px;">üìä Viewport Status</div>
                <button id="status-close-btn" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 0; width: 20px; height: 20px;">‚úï</button>
            </div>
            <div id="status-content" style="font-family: monospace; font-size: 11px; line-height: 1.6; color: #333;">
                Loading...
            </div>
        </div>

        <!-- Labels Details Panel - drops down below header -->
        <div id="labels-details-panel" style="position: absolute; top: 100%; right: 10px; width: 300px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-radius: 8px; padding: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 999; max-height: 450px; overflow-y: auto; font-size: 12px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div style="font-weight: 600;">üìã Saved Labels</div>
                <button id="labels-close-btn" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 0; width: 20px; height: 20px;">‚úï</button>
            </div>
            <div id="labels-list" style="max-height: 350px; overflow-y: auto;">
                <!-- Labels will be rendered here -->
            </div>
        </div>
    </div>

    <div id="map-container">
        <div class="panel">
            <div class="panel-header">OpenStreetMap</div>
            <div id="map-osm" class="map"></div>
        </div>
        <div class="panel">
            <div class="panel-header" style="justify-content: space-between;">
                <span id="panel2-title">Satellite</span>
                <select id="satellite-source-selector" style="margin-left: 10px; padding: 4px 8px; border: 1px solid #555; border-radius: 3px; background: #333; color: #fff; font-size: 13px;">
                    <option value="esri">Esri</option>
                    <option value="google">Google</option>
                </select>
            </div>
            <div id="map-rgb" class="map"></div>

        </div>
        <div class="panel">
            <div class="panel-header" style="justify-content: space-between;">
                Tessera Embeddings
                <select id="embedding-year-selector" style="display: none; margin-left: 10px; padding: 4px 8px; border: 1px solid #555; border-radius: 3px; background: #333; color: #fff; font-size: 13px;">
                    <option value="2024">2024</option>
                </select>
            </div>
            <div id="map-embedding" class="map"></div>
            <div id="coords-display" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0, 0, 0, 0.8); color: #00ff00; padding: 10px 15px; border-radius: 4px; font-family: monospace; font-size: 12px; font-weight: bold; pointer-events: none; display: none; z-index: 500; border: 1px solid #00ff00;">
                <div id="coords-text">Lat: 0.000000 | Lon: 0.000000</div>
            </div>
        </div>

        <!-- Panel 4: PCA/UMAP Visualization -->
        <div class="panel">
            <div class="panel-header" style="background: #4A5568; color: white; padding: 8px; font-weight: 600; font-size: 14px; display: flex; justify-content: space-between; align-items: center;">
                <span id="panel4-title">PCA (Embedding Space)</span>
                <select id="dim-reduction-selector" style="padding: 2px 6px; border: 1px solid #666; border-radius: 3px; background: #333; color: #fff; font-size: 12px; cursor: pointer;">
                    <option value="pca" selected>PCA (fast)</option>
                    <option value="umap">UMAP (slow)</option>
                </select>
            </div>
            <div id="map-umap" class="map"></div>
        </div>

        <!-- Panel 5: Distance Heatmap -->
        <div class="panel">
            <div class="panel-header" style="background: #805AD5; color: white; padding: 8px; font-weight: 600; font-size: 14px;">
                <span>Change Heatmap</span>
            </div>
            <div id="map-heatmap" class="map"></div>
            <!-- Message when years are the same -->
            <div id="heatmap-same-year-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.85); color: white; padding: 20px 30px; border-radius: 8px; font-size: 14px; z-index: 1000; white-space: nowrap; display: none;">
                Select different years in panels 3 and 6
            </div>
        </div>

        <!-- Panel 6: Second Year Embeddings -->
        <div class="panel">
            <div class="panel-header" style="background: #2C5282; color: white; padding: 8px; font-weight: 600; font-size: 14px; display: flex; justify-content: space-between; align-items: center;">
                <span>Tessera Embeddings</span>
                <select id="embedding-year-selector-2" style="display: none; margin-left: 10px; padding: 4px 8px; border: 1px solid #555; border-radius: 3px; background: #333; color: #fff; font-size: 13px;">
                </select>
            </div>
            <div id="map-embedding2" class="map"></div>
        </div>
    </div>

    <div id="status"></div>

    <!-- Progress Modal -->
    <div id="progress-overlay">
        <div id="progress-modal">
            <h2 id="progress-title">Processing...</h2>
            <div id="progress-file"></div>
            <div id="progress-message"></div>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="progress-bar">
                    <span id="progress-bar-text"></span>
                </div>
            </div>
            <div id="progress-percent">0%</div>
            <div id="progress-status">Starting...</div>
        </div>
    </div>

    <!-- Timeline Modal -->
    <div id="timeline-modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: white; border-radius: 8px; padding: 30px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div id="timeline-color-swatch" style="width: 18px; height: 18px; border-radius: 3px; border: 1px solid #999;"></div>
                    <h2 id="timeline-label-name" style="margin: 0; color: #333; font-size: 18px;"></h2>
                </div>
                <button id="timeline-close-btn" style="padding: 5px 12px; background: #ccc; color: #333; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 14px;">Close</button>
            </div>
            <div id="timeline-progress" style="display: none; margin-bottom: 16px; padding: 10px; background: #f0f4ff; border-radius: 4px; color: #333; font-size: 13px;">Loading...</div>
            <div id="timeline-results" style="display: none;">
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px;">
                    <thead>
                        <tr style="border-bottom: 2px solid #ddd;">
                            <th style="text-align: left; padding: 8px 6px; color: #333; font-size: 13px;">Year</th>
                            <th style="text-align: right; padding: 8px 6px; color: #333; font-size: 13px;">Pixels</th>
                            <th style="text-align: left; padding: 8px 6px; color: #333; font-size: 13px; width: 55%;">Coverage</th>
                        </tr>
                    </thead>
                    <tbody id="timeline-table-body"></tbody>
                </table>
                <div id="timeline-summary" style="padding: 12px; background: #f8f8f8; border-radius: 4px; font-size: 13px; color: #333;"></div>
            </div>
        </div>
    </div>

    <!-- Save Label Modal -->
    <div id="save-label-modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: white; border-radius: 8px; padding: 30px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 90%; max-width: 400px;">
            <h2 style="margin-top: 0; margin-bottom: 20px; color: #333;">Save Search as Label</h2>

            <div id="existing-labels-list" style="margin-bottom: 16px; max-height: 150px; overflow-y: auto; display: none;">
                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Use existing label:</label>
                <div id="existing-labels-rows"></div>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Label Name:</label>
                <input type="text" id="label-name-input" placeholder="e.g., residential_roads" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; box-sizing: border-box;">
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Color:</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="color" id="label-color-input" value="#FF6B6B" style="width: 60px; height: 40px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <span id="color-hex-display" style="font-family: monospace; color: #666;">#FF6B6B</span>
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button id="label-save-confirm" style="flex: 1; padding: 10px; background: #667eea; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 14px;">Save Label</button>
                <button id="label-save-cancel" style="flex: 1; padding: 10px; background: #ccc; color: #333; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 14px;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Auth check: set demo mode for unauthenticated users
        let isLoggedIn = false;
        fetch('/api/auth/status').then(r => r.json()).then(data => {
            if (data.logged_in && data.user) {
                isLoggedIn = true;
                document.getElementById('userName').textContent = data.user;
                document.getElementById('userInfo').style.display = 'flex';
            }
            if (data.auth_enabled && !data.logged_in) {
                // Demo mode: show login button instead of redirecting
                document.getElementById('loginBtn').style.display = '';
            }
        }).catch(() => {});

        function doLogout() {
            fetch('/api/auth/logout', {method: 'POST'}).then(() => {
                window.location.href = '/login.html';
            });
        }

        // Wrap global fetch to redirect on 401 (only for logged-in users)
        const _origFetch = window.fetch;
        window.fetch = function(url, opts) {
            return _origFetch(url, opts).then(resp => {
                if (resp.status === 401 && !String(url).includes('/api/auth/') && isLoggedIn) {
                    window.location.href = '/login.html?next=' + encodeURIComponent(window.location.pathname + window.location.search);
                }
                return resp;
            });
        };

        let TILE_SERVER = window.location.origin; // default, overridden by /api/config
        let center = [12.97, 77.59];  // Default: Bangalore
        let zoom = 12;

        // Viewport bounds for clipping
        let viewportBounds = null;  // Will be set from updateMapViewport()

        // Current embedding year
        let currentEmbeddingYear = '2024';
        let currentViewportName = 'tile_aligned';

        // Storage for labels: {panel: [[lat, lon, label], ...]}
        let labels = {
            'osm': [],
            'embedding': [],
            'rgb': []
        };

        // Storage for marker objects: {panel: {key: marker}}
        let markers = {
            'osm': {},
            'embedding': {},
            'rgb': {}
        };

        // Map instances
        let maps = {};

        // New state variables for 6-panel viewer
        let currentEmbeddingYear2 = '2024';  // Second year selector
        let umapData = null;                  // UMAP/PCA coordinates cache
        let umapCanvasLayer = null;           // 3D scatter plot layer (Three.js scene)
        let currentDimReduction = 'pca';      // 'pca' or 'umap' - default to PCA (fast)
        let heatmapCanvasLayer = null;        // Distance heatmap layer
        let explorerCanvasLayer2 = null;      // Explorer viz for Panel 6

        // Local FAISS data for client-side similarity search
        let faissLocal = null;  // {embeddings: Float32Array, coords: Int32Array, metadata: Object, pixelLookup: Map, numVectors: number, dim: number, viewport: string, year: string}

        // Satellite tile sources for Panel 2
        const satelliteSources = {
            esri: {
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                attribution: 'Esri World Imagery',
                exportUrl: (z, y, x) => `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`
            },
            google: {
                url: 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
                attribution: 'Google Satellite',
                exportUrl: (z, y, x) => `https://mt1.google.com/vt/lyrs=s&x=${x}&y=${y}&z=${z}`
            }
        };
        let currentSatelliteSource = 'esri';
        let satelliteTileLayer = null;

        // ===== IndexedDB Cache for FAISS Data =====
        const FaissCache = {
            DB_NAME: 'tee_faiss_cache',
            STORE_NAME: 'faiss_data',
            _db: null,

            async open() {
                if (this._db) return this._db;
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(this.DB_NAME, 3);
                    req.onupgradeneeded = (e) => {
                        const db = req.result;
                        // Delete old store on upgrade to invalidate stale cache
                        if (db.objectStoreNames.contains(this.STORE_NAME)) {
                            db.deleteObjectStore(this.STORE_NAME);
                        }
                        db.createObjectStore(this.STORE_NAME);
                    };
                    req.onsuccess = () => {
                        this._db = req.result;
                        resolve(this._db);
                    };
                    req.onerror = () => reject(req.error);
                });
            },

            async get(viewport, year) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_NAME, 'readonly');
                    const req = tx.objectStore(this.STORE_NAME).get(`${viewport}/${year}`);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => reject(req.error);
                });
            },

            async put(viewport, year, data) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_NAME, 'readwrite');
                    tx.objectStore(this.STORE_NAME).put(data, `${viewport}/${year}`);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            },

            async delete(viewport, year) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_NAME, 'readwrite');
                    tx.objectStore(this.STORE_NAME).delete(`${viewport}/${year}`);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            }
        };

        function parseNpy(buffer) {
            // Parse numpy .npy format: magic(6) + version(2) + header_len(2 or 4) + header + data
            const view = new DataView(buffer);
            const major = view.getUint8(6);
            let headerLen, dataOffset;
            if (major >= 2) {
                headerLen = view.getUint32(8, true);
                dataOffset = 12 + headerLen;
            } else {
                headerLen = view.getUint16(8, true);
                dataOffset = 10 + headerLen;
            }
            // Parse header string for dtype, shape, fortran_order
            const headerStr = new TextDecoder().decode(new Uint8Array(buffer, major >= 2 ? 12 : 10, headerLen));
            const descrMatch = headerStr.match(/'descr':\s*'([^']+)'/);
            const shapeMatch = headerStr.match(/'shape':\s*\(([^)]+)\)/);
            const fortranMatch = headerStr.match(/'fortran_order':\s*(True|False)/);
            const dtype = descrMatch ? descrMatch[1] : '<f4';
            const shape = shapeMatch ? shapeMatch[1].split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n)) : [];
            const fortranOrder = fortranMatch ? fortranMatch[1] === 'True' : false;
            const rawData = buffer.slice(dataOffset);
            return {rawData, dtype, shape, fortranOrder};
        }

        async function downloadFaissData(viewport, year) {
            // Check IndexedDB cache first
            const cached = await FaissCache.get(viewport, year);
            if (cached) {
                // Validate cached embeddings aren't all zeros (corrupt data)
                let hasNonZero = false;
                for (let i = 0; i < Math.min(1000, cached.embeddings.length); i++) {
                    if (cached.embeddings[i] !== 0) { hasNonZero = true; break; }
                }
                if (hasNonZero) {
                    console.log(`[FAISS-LOCAL] Cache hit for ${viewport}/${year}`);
                    const numVectors = cached.embeddings.length / 128;
                    const pixelLookup = new Map();
                    for (let i = 0; i < numVectors; i++) {
                        pixelLookup.set(`${cached.coords[i * 2]},${cached.coords[i * 2 + 1]}`, i);
                    }
                    faissLocal = {
                        embeddings: cached.embeddings,
                        coords: cached.coords,
                        metadata: cached.metadata,
                        pixelLookup,
                        numVectors,
                        dim: 128,
                        viewport,
                        year: String(year)
                    };
                    return faissLocal;
                } else {
                    console.warn(`[FAISS-LOCAL] Cached data for ${viewport}/${year} is all zeros ‚Äî purging stale cache`);
                    await FaissCache.delete(viewport, year);
                }
            }

            console.log(`[FAISS-LOCAL] Downloading FAISS data for ${viewport}/${year}...`);

            // Show download progress
            const overlay = document.getElementById('progress-overlay');
            const title = document.getElementById('progress-title');
            const message = document.getElementById('progress-message');
            const bar = document.getElementById('progress-bar');
            const percent = document.getElementById('progress-percent');
            const status = document.getElementById('progress-status');
            overlay.style.display = 'flex';
            title.textContent = 'Downloading FAISS Data';
            message.textContent = 'For local similarity search (one-time download)';
            status.textContent = 'Starting download...';
            bar.style.width = '0%';
            percent.textContent = '0%';

            try {
                // Fetch metadata first (small)
                const metaResp = await fetch(`/api/faiss-data/${viewport}/${year}/metadata.json`);
                if (!metaResp.ok) throw new Error(`metadata.json: ${metaResp.status}`);
                const metadata = await metaResp.json();
                status.textContent = 'Downloading pixel coordinates...';
                bar.style.width = '5%';
                percent.textContent = '5%';

                // Fetch coords
                const coordsResp = await fetch(`/api/faiss-data/${viewport}/${year}/pixel_coords.npy`);
                if (!coordsResp.ok) throw new Error(`pixel_coords.npy: ${coordsResp.status}`);
                const coordsBuf = await coordsResp.arrayBuffer();
                const coordsParsed = parseNpy(coordsBuf);
                const coordsData = new Int32Array(coordsParsed.rawData);
                status.textContent = 'Downloading embeddings...';
                bar.style.width = '10%';
                percent.textContent = '10%';

                // Fetch embeddings with progress tracking (large file)
                const embResp = await fetch(`/api/faiss-data/${viewport}/${year}/all_embeddings.npy`);
                if (!embResp.ok) throw new Error(`all_embeddings.npy: ${embResp.status}`);
                const contentLength = parseInt(embResp.headers.get('Content-Length') || '0');
                const reader = embResp.body.getReader();
                const chunks = [];
                let received = 0;

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    received += value.length;
                    if (contentLength > 0) {
                        const pct = Math.min(95, 10 + Math.round((received / contentLength) * 85));
                        bar.style.width = pct + '%';
                        percent.textContent = pct + '%';
                        status.textContent = `Downloading embeddings... ${(received / 1048576).toFixed(1)} / ${(contentLength / 1048576).toFixed(1)} MB`;
                    }
                }

                // Combine chunks into single buffer
                const embBuffer = new Uint8Array(received);
                let offset = 0;
                for (const chunk of chunks) {
                    embBuffer.set(chunk, offset);
                    offset += chunk.length;
                }
                const embParsed = parseNpy(embBuffer.buffer);
                const embDim = 128;
                let embeddingsData;

                // Handle dtype: uint8 needs conversion to float32
                if (embParsed.dtype === '|u1' || embParsed.dtype === '<u1') {
                    const raw = new Uint8Array(embParsed.rawData);
                    const N = embParsed.shape[0];
                    embeddingsData = new Float32Array(N * embDim);
                    if (embParsed.fortranOrder) {
                        // Fortran (column-major): raw layout is all col0, then col1, ...
                        for (let i = 0; i < N; i++) {
                            for (let d = 0; d < embDim; d++) {
                                embeddingsData[i * embDim + d] = raw[d * N + i];
                            }
                        }
                    } else {
                        for (let k = 0; k < raw.length; k++) embeddingsData[k] = raw[k];
                    }
                } else if (embParsed.dtype === '<f4') {
                    const raw = new Float32Array(embParsed.rawData);
                    const N = embParsed.shape[0];
                    if (embParsed.fortranOrder) {
                        embeddingsData = new Float32Array(N * embDim);
                        for (let i = 0; i < N; i++) {
                            for (let d = 0; d < embDim; d++) {
                                embeddingsData[i * embDim + d] = raw[d * N + i];
                            }
                        }
                    } else {
                        embeddingsData = raw;
                    }
                } else {
                    throw new Error(`Unsupported embedding dtype: ${embParsed.dtype}`);
                }

                status.textContent = 'Building lookup index...';
                bar.style.width = '97%';
                percent.textContent = '97%';

                const numVectors = embeddingsData.length / embDim;

                // Validate embeddings aren't all zeros (indicates corrupt source data)
                let hasNonZero = false;
                for (let i = 0; i < Math.min(1000, embeddingsData.length); i++) {
                    if (embeddingsData[i] !== 0) { hasNonZero = true; break; }
                }
                if (!hasNonZero) {
                    console.error(`[FAISS-LOCAL] Downloaded embeddings for ${viewport}/${year} are all zeros ‚Äî data is corrupt on server`);
                    status.textContent = `Error: embeddings for ${year} are corrupt (all zeros)`;
                    throw new Error(`Embeddings for ${year} are all zeros`);
                }

                const pixelLookup = new Map();
                for (let i = 0; i < numVectors; i++) {
                    pixelLookup.set(`${coordsData[i * 2]},${coordsData[i * 2 + 1]}`, i);
                }

                // Store in IndexedDB (without pixelLookup ‚Äî rebuilt on load)
                await FaissCache.put(viewport, year, {
                    embeddings: embeddingsData,
                    coords: coordsData,
                    metadata
                });

                bar.style.width = '100%';
                percent.textContent = '100%';
                status.textContent = `Ready! ${numVectors.toLocaleString()} vectors loaded.`;

                faissLocal = {
                    embeddings: embeddingsData,
                    coords: coordsData,
                    metadata,
                    pixelLookup,
                    numVectors,
                    dim: 128,
                    viewport,
                    year: String(year)
                };

                console.log(`[FAISS-LOCAL] Downloaded and cached: ${numVectors} vectors for ${viewport}/${year}`);
                return faissLocal;

            } catch (error) {
                console.error('[FAISS-LOCAL] Download failed:', error);
                status.textContent = `Download failed: ${error.message}`;
                throw error;
            } finally {
                setTimeout(() => { overlay.style.display = 'none'; }, 1500);
            }
        }

        // ===== Client-Side Search Functions =====

        function localExtract(lat, lon) {
            if (!faissLocal) return null;
            const gt = faissLocal.metadata.geotransform;
            // Affine transform: c=originX, a=pixelWidth, f=originY, e=pixelHeight(negative)
            const px = Math.trunc((lon - gt.c) / gt.a);
            const py = Math.trunc((lat - gt.f) / gt.e);

            // Try exact match first
            let idx = faissLocal.pixelLookup.get(`${px},${py}`);
            // Try 8-neighborhood if not found
            if (idx === undefined) {
                const offsets = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
                for (const [dx, dy] of offsets) {
                    idx = faissLocal.pixelLookup.get(`${px+dx},${py+dy}`);
                    if (idx !== undefined) break;
                }
            }
            if (idx === undefined) return null;

            // Return 128-dim embedding slice
            return faissLocal.embeddings.slice(idx * 128, (idx + 1) * 128);
        }

        function localSearchSimilar(embedding, threshold) {
            if (!faissLocal) return [];
            const gt = faissLocal.metadata.geotransform;
            const N = faissLocal.numVectors;
            const dim = faissLocal.dim;
            const emb = faissLocal.embeddings;
            const coords = faissLocal.coords;
            const matches = [];
            const threshSq = threshold * threshold;

            for (let i = 0; i < N; i++) {
                let distSq = 0;
                const base = i * dim;
                for (let d = 0; d < dim; d++) {
                    const diff = emb[base + d] - embedding[d];
                    distSq += diff * diff;
                }
                if (distSq <= threshSq) {
                    const px = coords[i * 2];
                    const py = coords[i * 2 + 1];
                    const lon = gt.c + px * gt.a;
                    const lat = gt.f + py * gt.e;
                    matches.push({lat, lon, distance: Math.sqrt(distSq)});
                }
            }
            return matches;
        }

        // ===== Cross-Year Timeline Functions =====

        // Union search: single pass counts pixels matching ANY of the label embeddings
        function searchMultiInFaissData(data, labelGroup) {
            const N = data.numVectors;
            const emb = data.embeddings;
            const searches = labelGroup.map(l => ({
                embedding: new Float32Array(l.embedding),
                threshSq: l.threshold * l.threshold
            }));
            let count = 0;
            for (let i = 0; i < N; i++) {
                const base = i * 128;
                let matched = false;
                for (const s of searches) {
                    let distSq = 0;
                    for (let d = 0; d < 128; d++) {
                        const diff = emb[base + d] - s.embedding[d];
                        distSq += diff * diff;
                    }
                    if (distSq <= s.threshSq) { matched = true; break; }
                }
                if (matched) count++;
            }
            return count;
        }

        async function loadFaissDataOnly(viewport, year) {
            const cached = await FaissCache.get(viewport, year);
            if (cached) {
                let hasNonZero = false;
                for (let i = 0; i < Math.min(1000, cached.embeddings.length); i++) {
                    if (cached.embeddings[i] !== 0) { hasNonZero = true; break; }
                }
                if (hasNonZero) {
                    return {
                        embeddings: cached.embeddings,
                        coords: cached.coords,
                        metadata: cached.metadata,
                        numVectors: cached.embeddings.length / 128
                    };
                }
            }
            // Not cached ‚Äî download via downloadFaissData, then restore faissLocal
            const saved = faissLocal;
            await downloadFaissData(viewport, year);
            const data = {
                embeddings: faissLocal.embeddings,
                coords: faissLocal.coords,
                metadata: faissLocal.metadata,
                numVectors: faissLocal.numVectors
            };
            faissLocal = saved;
            return data;
        }

        function getAvailableYears() {
            const sel = document.getElementById('embedding-year-selector');
            return Array.from(sel.options).map(o => parseInt(o.value)).sort();
        }

        async function computeLabelTimeline(labelGroup) {
            const years = getAvailableYears();
            const results = [];
            const progressEl = document.getElementById('timeline-progress');
            for (let i = 0; i < years.length; i++) {
                progressEl.textContent = `Loading year ${years[i]} (${i + 1} of ${years.length})...`;
                await new Promise(r => setTimeout(r, 0));
                const data = await loadFaissDataOnly(currentViewportName, years[i]);
                const count = searchMultiInFaissData(data, labelGroup);
                results.push({ year: years[i], count });
            }
            return results;
        }

        async function showLabelTimeline(labelName) {
            const labelGroup = savedLabels.filter(l => l.name === labelName);
            if (labelGroup.length === 0) return;
            const label = labelGroup[0];

            const overlay = document.getElementById('timeline-modal-overlay');
            const nameEl = document.getElementById('timeline-label-name');
            const swatchEl = document.getElementById('timeline-color-swatch');
            const progressEl = document.getElementById('timeline-progress');
            const resultsEl = document.getElementById('timeline-results');
            const bodyEl = document.getElementById('timeline-table-body');
            const summaryEl = document.getElementById('timeline-summary');

            // Setup and show modal
            const markerNote = labelGroup.length > 1 ? ` (${labelGroup.length} markers)` : '';
            nameEl.textContent = label.name + markerNote;
            swatchEl.style.background = label.color;
            progressEl.style.display = 'block';
            progressEl.textContent = 'Starting timeline analysis...';
            resultsEl.style.display = 'none';
            bodyEl.innerHTML = '';
            summaryEl.innerHTML = '';
            overlay.style.display = 'flex';

            try {
                const timeline = await computeLabelTimeline(labelGroup);
                const maxCount = Math.max(...timeline.map(t => t.count), 1);

                // Build table rows with bar chart
                bodyEl.innerHTML = timeline.map(t => {
                    const pct = (t.count / maxCount * 100).toFixed(1);
                    return `<tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 6px; color: #333; font-weight: 600; font-size: 13px;">${t.year}</td>
                        <td style="padding: 6px; text-align: right; color: #333; font-size: 13px;">${t.count.toLocaleString()}</td>
                        <td style="padding: 6px;">
                            <div style="background: #eee; border-radius: 3px; height: 18px; position: relative;">
                                <div style="background: ${label.color}; width: ${pct}%; height: 100%; border-radius: 3px; min-width: ${t.count > 0 ? '2px' : '0'};"></div>
                            </div>
                        </td>
                    </tr>`;
                }).join('');

                // Change summary
                if (timeline.length >= 2) {
                    const first = timeline[0];
                    const last = timeline[timeline.length - 1];
                    if (first.count > 0) {
                        const changePct = ((last.count - first.count) / first.count * 100).toFixed(1);
                        const direction = changePct > 0 ? 'increase' : changePct < 0 ? 'decrease' : 'no change';
                        const arrow = changePct > 0 ? '\u2191' : changePct < 0 ? '\u2193' : '\u2194';
                        summaryEl.innerHTML = `<strong>${arrow} ${Math.abs(changePct)}% ${direction}</strong> from ${first.year} (${first.count.toLocaleString()} px) to ${last.year} (${last.count.toLocaleString()} px)`;
                    } else {
                        summaryEl.innerHTML = `${first.year}: 0 pixels &rarr; ${last.year}: ${last.count.toLocaleString()} pixels`;
                    }
                }

                progressEl.style.display = 'none';
                resultsEl.style.display = 'block';
            } catch (err) {
                progressEl.textContent = `Error: ${err.message}`;
                console.error('[TIMELINE] Failed:', err);
            }
        }

        // Fetch current viewport and update map center/zoom
        async function updateMapViewport() {
            try {
                const response = await fetch('/api/viewports/current');
                const data = await response.json();

                if (data.success && data.viewport) {
                    const vp = data.viewport;
                    currentViewportName = vp.name;

                    // Update page title and heading with viewport name
                    const viewportDisplayName = currentViewportName.charAt(0).toUpperCase() + currentViewportName.slice(1);
                    document.title = `${viewportDisplayName} Viewer - OSM | Embeddings | RGB`;
                    const titleEl = document.getElementById('viewer-title');
                    if (titleEl) {
                        titleEl.textContent = `${viewportDisplayName} Viewer`;
                    }

                    // Parse bounds from viewport: [lon_min, lat_min, lon_max, lat_max]
                    if (vp.bounds_tuple && vp.bounds_tuple.length === 4) {
                        const [lonMin, latMin, lonMax, latMax] = vp.bounds_tuple;

                        // Store viewport bounds in Leaflet format: [[latMin, lonMin], [latMax, lonMax]]
                        viewportBounds = [[latMin, lonMin], [latMax, lonMax]];

                        // Calculate center (Leaflet expects [lat, lon])
                        center = [(latMin + latMax) / 2, (lonMin + lonMax) / 2];

                        // Calculate zoom level based on bounds
                        // Roughly: larger bounds = lower zoom, smaller bounds = higher zoom
                        const latSpan = latMax - latMin;
                        const lonSpan = lonMax - lonMin;
                        const maxSpan = Math.max(latSpan, lonSpan);

                        if (maxSpan > 0.5) zoom = 11;
                        else if (maxSpan > 0.2) zoom = 12;
                        else if (maxSpan > 0.1) zoom = 13;
                        else if (maxSpan > 0.05) zoom = 14;
                        else zoom = 15;
                    }
                }
            } catch (error) {
                console.warn('[VIEWPORT] Could not fetch viewport, using defaults:', error);
            }
        }

        // Create all three maps
        function createMaps() {
            // OSM Map
            maps.osm = L.map('map-osm', {
                center: center,
                zoom: zoom,
                zoomControl: false,
                minZoom: 6,
                maxZoom: 18,
                doubleClickZoom: false  // We use dblclick for similarity search
            });
            L.control.zoom({position: 'bottomright'}).addTo(maps.osm);

            // Apply same bounds as embedding/RGB maps so all maps stay in sync
            if (viewportBounds) {
                maps.osm.setMaxBounds(viewportBounds);
                maps.osm.options.maxBoundsViscosity = 1.0;
            }

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(maps.osm);

            // Embedding Map (Tessera)
            maps.embedding = L.map('map-embedding', {
                center: center,
                zoom: zoom,
                zoomControl: false,
                minZoom: 6,
                maxZoom: 18,
                doubleClickZoom: false  // We use dblclick for similarity search
            });
            L.control.zoom({position: 'bottomright'}).addTo(maps.embedding);

            let embeddingLayer = L.pixelatedTileLayer(`${TILE_SERVER}/tiles/${currentViewportName}/${currentEmbeddingYear}/{z}/{x}/{y}.png`, {
                attribution: 'Tessera Embeddings',
                opacity: 1.0,
                maxZoom: 18,
                maxNativeZoom: 17,
                minZoom: 6,
                tileSize: 256
            }).addTo(maps.embedding);

            // Clip embedding map to viewport bounds
            if (viewportBounds) {
                maps.embedding.setMaxBounds(viewportBounds);
                maps.embedding.options.maxBoundsViscosity = 1.0;  // Prevent bouncing when hitting edges
            }

            // RGB Satellite Map
            maps.rgb = L.map('map-rgb', {
                center: center,
                zoom: zoom,
                zoomControl: false,
                minZoom: 6,
                maxZoom: 18,
                doubleClickZoom: false  // We use dblclick for similarity search
            });
            L.control.zoom({position: 'bottomright'}).addTo(maps.rgb);

            // Initialize satellite tile layer
            satelliteTileLayer = L.tileLayer(satelliteSources.esri.url, {
                attribution: satelliteSources.esri.attribution,
                opacity: 1.0,
                maxZoom: 18,
                minZoom: 6,
                crossOrigin: 'anonymous'
            });
            satelliteTileLayer.addTo(maps.rgb);

            // Satellite source selector
            const satSelector = document.getElementById('satellite-source-selector');
            if (satSelector) {
                satSelector.addEventListener('change', function() {
                    const src = satelliteSources[this.value];
                    if (!src) return;
                    currentSatelliteSource = this.value;
                    maps.rgb.removeLayer(satelliteTileLayer);
                    satelliteTileLayer = L.tileLayer(src.url, {
                        attribution: src.attribution,
                        opacity: 1.0,
                        maxZoom: 18,
                        minZoom: 6,
                        crossOrigin: 'anonymous'
                    });
                    satelliteTileLayer.addTo(maps.rgb);
                });
            }

            // Clip RGB satellite map to viewport bounds
            if (viewportBounds) {
                maps.rgb.setMaxBounds(viewportBounds);
                maps.rgb.options.maxBoundsViscosity = 1.0;  // Prevent bouncing when hitting edges
            }

            // Panel 4: UMAP ‚Äî Three.js scene, initialised in loadUMAP()

            // Panel 5: Heatmap (geographic, synced to OSM)
            maps.heatmap = L.map('map-heatmap', {
                center: center,
                zoom: zoom,
                zoomControl: false,
                minZoom: 6,
                maxZoom: 18,
                doubleClickZoom: false  // We use dblclick for similarity search
            });
            L.control.zoom({position: 'bottomright'}).addTo(maps.heatmap);

            // No background layer for heatmap - pure color visualization

            if (viewportBounds) {
                maps.heatmap.setMaxBounds(viewportBounds);
                maps.heatmap.options.maxBoundsViscosity = 1.0;
            }

            // Recompute heatmap when zoom changes (to adjust sampling based on zoom level)
            let heatmapZoomTimeout;
            maps.heatmap.on('zoomend', () => {
                clearTimeout(heatmapZoomTimeout);
                heatmapZoomTimeout = setTimeout(() => {
                    if (heatmapCanvasLayer && heatmapCanvasLayer.distances && heatmapCanvasLayer.distances.length > 0) {
                        loadHeatmap();
                    }
                }, 500);  // Debounce to avoid rapid recomputes
            });

            // Panel 6: Second Year Embeddings (geographic, synced to OSM)
            maps.embedding2 = L.map('map-embedding2', {
                center: center,
                zoom: zoom,
                zoomControl: false,
                minZoom: 6,
                maxZoom: 18,
                doubleClickZoom: false  // We use dblclick for similarity search
            });
            L.control.zoom({position: 'bottomright'}).addTo(maps.embedding2);

            let embedding2Layer = L.pixelatedTileLayer(`${TILE_SERVER}/tiles/${currentViewportName}/${currentEmbeddingYear2}/{z}/{x}/{y}.png`, {
                attribution: 'Tessera Embeddings',
                opacity: 1.0,
                maxZoom: 18,
                maxNativeZoom: 17,
                tileSize: 256
            }).addTo(maps.embedding2);

            if (viewportBounds) {
                maps.embedding2.setMaxBounds(viewportBounds);
                maps.embedding2.options.maxBoundsViscosity = 1.0;
            }

            window.embedding2Layer = embedding2Layer;

            // Click handling with dblclick detection
            // We need to delay single-click to distinguish from double-click
            let clickTimeout = null;

            Object.keys(maps).forEach(panel => {
                maps[panel].on('click', function(e) {
                    // Clear any pending click - might be start of double-click
                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                    }
                    // Delay single-click action to allow dblclick to cancel it
                    clickTimeout = setTimeout(() => {
                        handleUnifiedClick(e.latlng.lat, e.latlng.lng);
                        clickTimeout = null;
                    }, 250);
                });

                // Double-click triggers similarity search
                maps[panel].on('dblclick', function(e) {
                    // Cancel pending single-click
                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                    }
                    handleSimilaritySearch(e.latlng.lat, e.latlng.lng);
                });

                // Show lat/lon in header on mousemove
                maps[panel].on('mousemove', function(e) {
                    const el = document.getElementById('header-coords');
                    if (el) el.textContent = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
                });
                maps[panel].on('mouseout', function() {
                    const el = document.getElementById('header-coords');
                    if (el) el.textContent = '';
                });
            });

            // Synchronize maps
            syncMaps();

            // Store reference to embedding layer for switching years
            window.embeddingLayer = embeddingLayer;

            return embeddingLayer;
        }

        // Load available years and populate dropdown
        async function loadAvailableYears() {
            try {
                const response = await fetch(`/api/viewports/${currentViewportName}/available-years`);
                const data = await response.json();

                if (data.success && data.years && data.years.length > 0) {
                    // Set current year to first available year (or 2024 if available)
                    const yearToUse = data.years.includes(2024) ? 2024 : data.years[0];
                    currentEmbeddingYear = yearToUse.toString();
                    console.log(`‚úì Available years: ${data.years.join(', ')}, using: ${yearToUse}`);

                    if (data.years.length > 1) {
                        // Show selector if more than 1 year available
                        const yearSelector = document.getElementById('embedding-year-selector');
                        yearSelector.style.display = 'inline-block';
                        yearSelector.innerHTML = '';

                        // Populate dropdown (newest first)
                        data.years.forEach(year => {
                            const option = document.createElement('option');
                            option.value = year;
                            option.textContent = year;
                            if (year === yearToUse) option.selected = true;
                            yearSelector.appendChild(option);
                        });

                        // Add change listener
                        yearSelector.addEventListener('change', (e) => {
                            switchEmbeddingYear(parseInt(e.target.value));
                        });
                    } else {
                        // Hide selector if only 1 year
                        const yearSelector = document.getElementById('embedding-year-selector');
                        yearSelector.style.display = 'none';
                    }

                    // Reload embedding layer with correct year
                    if (embeddingLayer) {
                        maps.embedding.removeLayer(embeddingLayer);
                    }
                    embeddingLayer = L.pixelatedTileLayer(
                        `${TILE_SERVER}/tiles/${currentViewportName}/${currentEmbeddingYear}/{z}/{x}/{y}.png`,
                        {
                            tileSize: 256,
                            bounds: viewportBounds
                        }
                    );
                    embeddingLayer.addTo(maps.embedding);
                } else {
                    console.warn('No available years found');
                }
            } catch (error) {
                console.error('Error loading available years:', error);
            }
        }

        // Switch to different embedding year
        async function switchEmbeddingYear(year) {
            console.log(`üìÖ Switching to year ${year}`);
            currentEmbeddingYear = year.toString();

            // Remove old layer
            if (maps.embedding.hasLayer(window.embeddingLayer)) {
                maps.embedding.removeLayer(window.embeddingLayer);
            }

            // Create new layer with selected year
            window.embeddingLayer = L.pixelatedTileLayer(
                `${TILE_SERVER}/tiles/${currentViewportName}/${currentEmbeddingYear}/{z}/{x}/{y}.png`,
                {
                    tileSize: 256,
                    bounds: viewportBounds
                }
            );

            window.embeddingLayer.addTo(maps.embedding);
            console.log(`‚úì Switched to year ${year}`);

            // Always reload FAISS data for the new year (needed for similarity search)
            if (faissLocal && faissLocal.year !== String(year)) {
                try {
                    await downloadFaissData(currentViewportName, year);
                } catch (e) {
                    console.error(`[FAISS] Failed to load data for year ${year}:`, e);
                }
            }

            // Update labels (re-compute with new year's embeddings)
            if (savedLabels.length > 0) {
                console.log(`üîÑ Updating ${savedLabels.length} saved labels for year ${year}`);
                await refreshLabelsForYear(year);
            }

            // Re-run explorer search if one is active
            if (currentSearchCache && currentSearchCache.sourcePixel) {
                const sourcePixel = currentSearchCache.sourcePixel;
                console.log(`üîÑ Re-running search for ${sourcePixel.lat.toFixed(6)}, ${sourcePixel.lon.toFixed(6)} with year ${year}`);
                explorerClick(sourcePixel.lat, sourcePixel.lon);
            }

            // Update heatmap (compares Panel 3 and Panel 6)
            loadHeatmap();

            // Note: UMAP is NOT reloaded on year switch. It's a projection of
            // embeddings from one year, computed once on page load. Recomputing
            // on every year switch would be wasteful (~30s each time).
        }

        // Refresh all saved labels for a new year
        async function refreshLabelsForYear(year) {
            // Ensure FAISS data is loaded for the target year
            if (!faissLocal || faissLocal.year !== String(year)) {
                try {
                    await downloadFaissData(currentViewportName, year);
                } catch (e) {
                    console.error(`[LABEL] Cannot load FAISS data for year ${year}:`, e);
                    return;
                }
            }

            for (const label of savedLabels) {
                try {
                    const embedding = localExtract(label.source_pixel.lat, label.source_pixel.lon);
                    if (!embedding) {
                        console.warn(`[LABEL] No embedding for ${label.name} at source pixel`);
                        continue;
                    }
                    const matches = localSearchSimilar(embedding, label.threshold);
                    label.pixels = matches;
                    label.pixel_count = matches.length;
                } catch (error) {
                    console.error(`[LABEL] Error refreshing ${label.name}:`, error);
                }
            }

            // Redraw overlays with updated pixels
            updateOverlay();
        }

        // Load available years for Panel 6 (second year selector)
        async function loadAvailableYears2() {
            try {
                const response = await fetch(`/api/viewports/${currentViewportName}/available-years`);
                const data = await response.json();

                if (data.success && data.years && data.years.length > 0) {
                    const yearToUse = data.years.includes(2024) ? 2024 : data.years[0];
                    currentEmbeddingYear2 = yearToUse.toString();
                    console.log(`‚úì Panel 6 available years: ${data.years.join(', ')}, using: ${yearToUse}`);

                    if (data.years.length > 1) {
                        const yearSelector = document.getElementById('embedding-year-selector-2');
                        yearSelector.style.display = 'inline-block';
                        yearSelector.innerHTML = '';

                        data.years.forEach(year => {
                            const option = document.createElement('option');
                            option.value = year;
                            option.textContent = year;
                            if (year === yearToUse) option.selected = true;
                            yearSelector.appendChild(option);
                        });

                        yearSelector.addEventListener('change', (e) => {
                            switchEmbeddingYear2(e.target.value);
                        });
                    }

                    // Reload embedding layer with correct year
                    if (window.embedding2Layer) {
                        maps.embedding2.removeLayer(window.embedding2Layer);
                    }
                    window.embedding2Layer = L.pixelatedTileLayer(
                        `${TILE_SERVER}/tiles/${currentViewportName}/${currentEmbeddingYear2}/{z}/{x}/{y}.png`,
                        {
                            tileSize: 256,
                            bounds: viewportBounds
                        }
                    );
                    window.embedding2Layer.addTo(maps.embedding2);
                }
            } catch (error) {
                console.error('Error loading available years for Panel 6:', error);
            }
        }

        // Switch Panel 6 to different year
        function switchEmbeddingYear2(year) {
            console.log(`üìÖ Switching Panel 6 to year ${year}`);
            currentEmbeddingYear2 = year.toString();

            // Remove old layer
            if (maps.embedding2.hasLayer(window.embedding2Layer)) {
                maps.embedding2.removeLayer(window.embedding2Layer);
            }

            // Create new layer with selected year
            window.embedding2Layer = L.pixelatedTileLayer(
                `${TILE_SERVER}/tiles/${currentViewportName}/${currentEmbeddingYear2}/{z}/{x}/{y}.png`,
                {
                    tileSize: 256,
                    bounds: viewportBounds
                }
            );

            window.embedding2Layer.addTo(maps.embedding2);
            console.log(`‚úì Switched Panel 6 to year ${year}`);

            // Update heatmap (compares Panel 3 and Panel 6)
            loadHeatmap();
        }

        // Synchronize all maps - any panel can trigger sync to all others
        function syncMaps() {
            let syncing = false;
            const geoPanels = ['osm', 'embedding', 'rgb', 'heatmap', 'embedding2'];

            function doSync(sourcePanel) {
                if (syncing) return;
                syncing = true;

                const sourceMap = maps[sourcePanel];
                const center = sourceMap.getCenter();
                const zoom = sourceMap.getZoom();

                // Sync all other geographic panels (not Panel 4 which is Three.js)
                geoPanels.forEach(panel => {
                    if (panel !== sourcePanel) {
                        maps[panel].setView(center, zoom, {animate: false});
                    }
                });

                syncing = false;
            }

            // Each geographic panel can trigger sync
            geoPanels.forEach(panel => {
                maps[panel].on('move zoom', () => doSync(panel));
            });
        }

        // Add marker
        function addMarker(panel, lat, lon, label) {
            const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;

            // Check if marker already exists (remove it)
            if (markers[panel][key]) {
                removeMarker(panel, lat, lon);
                return;
            }

            // Create marker
            const marker = L.marker([lat, lon], {
                title: label
            }).addTo(maps[panel]);

            marker.bindPopup(`<div class="marker-popup">${label}</div>`);

            // Store marker
            markers[panel][key] = marker;
            labels[panel].push([lat, lon, label]);

            updateLabelCount();
            console.log(`Added '${label}' at (${lat.toFixed(4)}, ${lon.toFixed(4)}) on ${panel} panel`);
        }

        // Remove marker
        function removeMarker(panel, lat, lon) {
            const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;

            if (markers[panel][key]) {
                maps[panel].removeLayer(markers[panel][key]);
                delete markers[panel][key];

                // Remove from labels
                labels[panel] = labels[panel].filter(
                    ([la, lo]) => Math.abs(la - lat) > 0.00001 || Math.abs(lo - lon) > 0.00001
                );

                updateLabelCount();
                console.log(`Removed marker at (${lat.toFixed(4)}, ${lon.toFixed(4)}) from ${panel} panel`);
            }
        }

        // Helper function to get viewport-specific localStorage key
        function getLabelsStorageKey() {
            return `${currentViewportName}_labels_3panel`;
        }

        // Update label count
        function updateLabelCount() {
            const oldTotal = Object.values(labels).reduce((sum, arr) => sum + arr.length, 0);
            const newTotal = Object.values(embeddingLabels).reduce((sum, arr) => sum + arr.length, 0);
            const total = oldTotal + newTotal;
            document.getElementById('label-count').textContent = `Labels: ${total}`;
        }

        // Save labels to localStorage
        function saveLabels() {
            const saveData = {
                // Old system: markers on maps
                labels: labels,
                embeddingYear: currentEmbeddingYear,
                // New system: embeddings for similarity search
                definedLabels: definedLabels,
                embeddingLabels: embeddingLabels,
                labelColors: labelColors
            };
            localStorage.setItem(getLabelsStorageKey(), JSON.stringify(saveData));
            const oldTotal = Object.values(labels).reduce((sum, arr) => sum + arr.length, 0);
            const newTotal = Object.values(embeddingLabels).reduce((sum, arr) => sum + arr.length, 0);
            console.log(`‚úì Saved to ${getLabelsStorageKey()}: ${oldTotal} markers + ${newTotal} embeddings with colors`);
        }

        // Load labels from localStorage
        function loadLabels() {
            const storageKey = getLabelsStorageKey();
            let stored = localStorage.getItem(storageKey);

            if (stored) {
                try {
                    const saveData = JSON.parse(stored);

                    // Restore old marker system
                    if (saveData.labels) {
                        Object.keys(saveData.labels).forEach(panel => {
                            saveData.labels[panel].forEach(([lat, lon, label]) => {
                                addMarker(panel, lat, lon, label);
                            });
                        });
                        const oldCount = Object.values(saveData.labels).reduce((sum, arr) => sum + arr.length, 0);
                        console.log(`‚úì Loaded ${oldCount} markers`);
                    }

                    // Restore new embedding labels system
                    if (saveData.definedLabels && saveData.embeddingLabels) {
                        definedLabels = saveData.definedLabels;
                        embeddingLabels = saveData.embeddingLabels;
                        if (saveData.labelColors) {
                            labelColors = saveData.labelColors;
                        }
                        updateLabelDropdown();
                        updateLabelCount();
                        const newCount = Object.values(embeddingLabels).reduce((sum, arr) => sum + arr.length, 0);
                        console.log(`‚úì Loaded ${newCount} embeddings for ${definedLabels.length} labels with colors`);
                    }
                } catch (error) {
                    console.error('Error loading labels:', error);
                }
            }
        }

        // Clear all labels
        function clearAllLabels() {
            if (!confirm('Clear all labels?')) return;

            Object.keys(markers).forEach(panel => {
                Object.values(markers[panel]).forEach(marker => {
                    maps[panel].removeLayer(marker);
                });
                markers[panel] = {};
                labels[panel] = [];
            });

            updateLabelCount();
            console.log('Cleared all labels');
        }

        // Export labels to JSON
        function exportLabels() {
            const exportData = {
                embeddingYear: currentEmbeddingYear,
                labels: labels,
                timestamp: new Date().toISOString()
            };
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${currentViewportName}_labels_${currentEmbeddingYear}_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            console.log('Exported labels to JSON file');
        }

        // =====================================================================
        // EMBEDDING LABELING SYSTEM
        // =====================================================================

        // Label management
        let definedLabels = [];  // List of all defined labels
        let embeddingLabels = {}; // {label: [[128-dim vector], [128-dim vector], ...]}
        let labelColors = {};    // {label: "#FF0000", ...}
        let labelPixels = {}; // {key: {label: 'road', coordinate: {lat, lon}}} for visualization

        // Similarity search tracking
        let similarPixels = {};          // {key: {label, coordinate, embedding, distance, rectangle, marker}}
        let isSimilaritySearchActive = false;
        let activeSearchLabel = null;

        // Explorer Mode variables
        let explorerResults = null;      // Cache: {allMatches, queryTime, cacheThreshold, sourcePixel}
        let explorerVisualization = null; // Layer group for visualization
        let explorerCanvasLayer = null;   // Direct canvas layer (reused on slider changes)

        // Cross-panel triangle markers (one per geographic panel, cleared on each new click)
        let crossPanelMarkers = {osm: null, rgb: null, embedding: null, heatmap: null, embedding2: null};
        let persistentLabelMarkers = []; // {labelId, markers: {osm, rgb, ...}}

        const TRIANGLE_ICON = L.divIcon({
            className: 'triangle-marker',
            html: '<svg width="20" height="20" viewBox="0 0 20 20" style="overflow:visible;"><polygon points="0,0 20,0 10,20" fill="#FFD700" stroke="#FF8C00" stroke-width="2" stroke-linejoin="round"/></svg>',
            iconSize: [20, 20],
            iconAnchor: [10, 20]  // Tip of triangle anchored to the coordinate
        });

        function makeColoredTriangleIcon(fillColor) {
            return L.divIcon({
                className: 'triangle-marker',
                html: `<svg width="20" height="20" viewBox="0 0 20 20" style="overflow:visible;"><polygon points="0,0 20,0 10,20" fill="${fillColor}" stroke="#333" stroke-width="2" stroke-linejoin="round"/></svg>`,
                iconSize: [20, 20],
                iconAnchor: [10, 20]
            });
        }

        function setCrossPanelMarker(mapKey, lat, lon) {
            if (crossPanelMarkers[mapKey]) {
                maps[mapKey].removeLayer(crossPanelMarkers[mapKey]);
            }
            crossPanelMarkers[mapKey] = L.marker([lat, lon], { icon: TRIANGLE_ICON }).addTo(maps[mapKey]);
        }

        function clearCrossPanelMarkers() {
            for (const key of Object.keys(crossPanelMarkers)) {
                if (crossPanelMarkers[key]) {
                    maps[key].removeLayer(crossPanelMarkers[key]);
                    crossPanelMarkers[key] = null;
                }
            }
        }

        // Unified click handler: places marker on ALL panels at the same location
        function handleUnifiedClick(lat, lon) {
            console.log(`[CLICK] Unified click at ${lat.toFixed(6)}, ${lon.toFixed(6)}`);

            // Clear all existing markers
            clearCrossPanelMarkers();

            // Place marker on all geographic panels
            ['osm', 'rgb', 'embedding', 'heatmap', 'embedding2'].forEach(panel => {
                setCrossPanelMarker(panel, lat, lon);
            });

            // Highlight nearest point in Panel 4 (PCA/UMAP)
            highlightUMAPPoint(lat, lon);
        }

        // Double-click handler: triggers similarity search, shows results on Panel 2 AND Panel 4
        async function handleSimilaritySearch(lat, lon) {
            console.log(`[DBLCLICK] Similarity search at ${lat.toFixed(6)}, ${lon.toFixed(6)}`);

            // First, place markers at the search location
            handleUnifiedClick(lat, lon);

            // Then trigger similarity search (results shown on Panel 2)
            await explorerClick(lat, lon);

            // Panel 4 highlighting is handled by updateExplorerVisualization()
        }

        // Pick a contrastive color not already in use. Never offers yellow or black.
        function nextLabelColor() {
            // Curated palette of distinct, saturated hues (no yellow, no black)
            const palette = [
                '#FF6B6B', // red
                '#4ECDC4', // teal
                '#45B7D1', // sky blue
                '#96CEB4', // sage green
                '#DDA15E', // amber/orange
                '#BC6C25', // brown
                '#9B59B6', // purple
                '#E74C3C', // crimson
                '#1ABC9C', // turquoise
                '#3498DB', // blue
                '#E67E22', // orange
                '#2ECC71', // emerald
                '#8E44AD', // dark purple
                '#E84393', // pink
                '#00CEC9', // cyan
                '#6C5CE7', // indigo
                '#FD79A8', // light pink
                '#00B894', // mint
                '#D63031', // dark red
                '#0984E3', // bright blue
            ];

            // Collect all colors currently in use
            const usedColors = new Set();
            for (const c of Object.values(labelColors)) usedColors.add(c.toUpperCase());
            for (const l of savedLabels) if (l.color) usedColors.add(l.color.toUpperCase());

            // Return first unused palette color
            for (const c of palette) {
                if (!usedColors.has(c.toUpperCase())) return c;
            }

            // All palette colors used ‚Äî generate a random saturated hue (avoid yellow 40-70 deg, black)
            let hue;
            do { hue = Math.floor(Math.random() * 360); } while (hue >= 40 && hue <= 70);
            const sat = 65 + Math.floor(Math.random() * 20); // 65-85%
            const lit = 45 + Math.floor(Math.random() * 15); // 45-60%
            // Convert HSL to hex
            const h = hue, s = sat / 100, l = lit / 100;
            const a2 = s * Math.min(l, 1 - l);
            const f = n => { const k = (n + h / 30) % 12; return l - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1); };
            const toHex = x => Math.round(x * 255).toString(16).padStart(2, '0');
            return '#' + toHex(f(0)) + toHex(f(8)) + toHex(f(4));
        }

        // Create a new label
        function createLabelDialog() {
            const labelName = prompt('Enter new label name (e.g., "road", "building", "tree"):');
            if (labelName && labelName.trim()) {
                const label = labelName.trim();
                if (definedLabels.includes(label)) {
                    alert(`Label "${label}" already exists!`);
                    return;
                }

                showColorPickerModal(label, nextLabelColor());
            }
        }

        function showColorPickerModal(label, defaultColor) {
            // Create modal backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'color-picker-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create modal dialog
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                font-family: Arial, sans-serif;
                max-width: 400px;
                width: 90%;
            `;

            modal.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">Select color for "${label}"</h3>

                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                        <label style="font-weight: bold; margin: 0;">Color:</label>
                        <input type="color" id="label-color-picker" value="${defaultColor}" style="width: 60px; height: 50px; cursor: pointer; border: 2px solid #ddd; border-radius: 6px;">
                        <div id="color-preview" style="display: inline-block; width: 60px; height: 50px; background: ${defaultColor}; border: 2px solid #999; border-radius: 6px;"></div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="document.getElementById('color-picker-backdrop').remove();" style="padding: 10px 20px; background: #ddd; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Cancel</button>
                        <button onclick="confirmLabelColorSelection('${label}');" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Create Label</button>
                    </div>
                </div>
            `;

            backdrop.appendChild(modal);
            document.body.appendChild(backdrop);

            // Live preview color picker
            const colorPicker = document.getElementById('label-color-picker');
            const preview = document.getElementById('color-preview');
            colorPicker.addEventListener('input', (e) => {
                preview.style.background = e.target.value;
            });

            // Focus color picker
            colorPicker.focus();
        }

        function confirmLabelColorSelection(label) {
            const selectedColor = document.getElementById('label-color-picker').value;

            if (definedLabels.includes(label)) {
                alert(`Label "${label}" already exists!`);
                return;
            }

            definedLabels.push(label);
            definedLabels.sort();
            embeddingLabels[label] = [];
            labelColors[label] = selectedColor;

            // Close modal
            const backdrop = document.getElementById('color-picker-backdrop');
            if (backdrop) backdrop.remove();

            // Update UI
            updateLabelDropdown();
            saveLabels();
            console.log(`Created label: "${label}" with color ${selectedColor}`);
        }

        // Update the active label dropdown
        function updateLabelDropdown() {            const select = document.getElementById('active-label');
            if (!select) {
                console.error('[DROPDOWN] ERROR: Could not find element with id="active-label"');
                return;
            }
            select.innerHTML = '';
            if (definedLabels.length === 0) {                select.innerHTML = '<option value="">No labels yet</option>';
                select.disabled = true;
            } else {                definedLabels.forEach(label => {
                    const option = document.createElement('option');
                    option.value = label;
                    option.textContent = label;
                    select.appendChild(option);
                });
                select.value = definedLabels[0];
                select.disabled = false;
            }
        }


        // Update coordinates display on mouse move over embedding map
        function updateCoordinatesDisplay(lat, lon) {
            const coordsText = document.getElementById('coords-text');
            if (coordsText) {
                coordsText.textContent = `Lat: ${lat.toFixed(6)} | Lon: ${lon.toFixed(6)}`;
            }
        }

        // Get a color for a label (for visualization)
        function getColorForLabel(label) {
            // Use user-selected color if available
            if (labelColors[label]) {
                return labelColors[label];
            }

            // Fallback to predefined colors
            const colors = {
                'road': '#FF6B6B',
                'building': '#4ECDC4',
                'tree': '#45B7D1',
                'water': '#96CEB4',
                'grass': '#FFEAA7',
                'car': '#DDA15E',
                'person': '#BC6C25'
            };
            if (colors[label]) return colors[label];

            // Generate consistent color from label name as last resort
            let hash = 0;
            for (let i = 0; i < label.length; i++) {
                hash = label.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = '#' + (Math.abs(hash) % 0xFFFFFF).toString(16).padStart(6, '0');
            return color;
        }

        // Invert RGB color: (R, G, B) -> (255-R, 255-G, 255-B)
        function invertColor(hexColor) {
            // Remove # if present
            const color = hexColor.replace('#', '');
            // Parse hex to RGB
            const r = parseInt(color.substr(0, 2), 16);
            const g = parseInt(color.substr(2, 2), 16);
            const b = parseInt(color.substr(4, 2), 16);
            // Invert: 255 - value
            const invR = (255 - r).toString(16).padStart(2, '0');
            const invG = (255 - g).toString(16).padStart(2, '0');
            const invB = (255 - b).toString(16).padStart(2, '0');
            return '#' + invR + invG + invB;
        }

        // Calculate pixel size in degrees (10m x 10m)
        function calculatePixelBounds(lat, lon) {
            // Each pixel is 10m x 10m
            // 1 degree latitude = ~111.32 km = 111320 m
            // 1 degree longitude = ~111.32 * cos(latitude) km at that latitude
            const latPerMeter = 1 / 111320;
            const lonPerMeter = 1 / (111320 * Math.cos(lat * Math.PI / 180));

            const pixelSizeMeters = 10;  // 10m x 10m pixel
            const latOffset = pixelSizeMeters * latPerMeter / 2;
            const lonOffset = pixelSizeMeters * lonPerMeter / 2;

            return [
                [lat - latOffset, lon - lonOffset],  // Southwest
                [lat + latOffset, lon + lonOffset]   // Northeast
            ];
        }

        // Delete a labeled pixel
        function deleteLabeledPixel(key, pixelData) {
            // Confirm deletion
            if (!confirm(`Delete labeled pixel "${pixelData.label}"?`)) {
                return;
            }

            // Find and remove the embedding from the label's embedding array
            const embeddingIndex = embeddingLabels[pixelData.label].findIndex(emb =>
                JSON.stringify(emb) === JSON.stringify(pixelData.embedding)
            );

            if (embeddingIndex !== -1) {
                embeddingLabels[pixelData.label].splice(embeddingIndex, 1);
                console.log(`[DELETE] Removed embedding from label "${pixelData.label}"`);
            }

            // Remove the visual elements (rectangle and marker)
            if (pixelData.rectangle) {
                maps.embedding.removeLayer(pixelData.rectangle);
            }
            if (pixelData.marker) {
                maps.embedding.removeLayer(pixelData.marker);
            }

            // Remove from tracking
            delete labelPixels[key];

            // Update label count
            updateLabelCount();

            console.log(`[DELETE] Deleted labeled pixel at key "${key}"`);
        }

        // Highlight labeled pixel on embedding map as rectangle
        function highlightLabeledPixel(lat, lon, label, key) {
            const labelColor = getColorForLabel(label);
            const bounds = calculatePixelBounds(lat, lon);

            const rectangle = L.rectangle(bounds, {
                color: labelColor,  // Label color outline
                weight: 1,  // Thin outline
                opacity: 1.0,
                fill: true,
                fillColor: labelColor,  // Label color fill
                fillOpacity: 0.8,  // Solid color
                className: 'labeled-pixel'
            }).addTo(maps.embedding);

            // Show label on hover
            const popupContent = `<div style="font-weight: 600; color: ${labelColor}; font-size: 12px;">${label}</div>`;
            rectangle.bindPopup(popupContent);

            rectangle.on('mouseover', function() {
                this.openPopup();
                this.setStyle({fillOpacity: 0.95, weight: 2});  // Brighten on hover
            });
            rectangle.on('mouseout', function() {
                this.closePopup();
                this.setStyle({fillOpacity: 0.8, weight: 1});  // Reset
            });

            // Click to delete
            rectangle.on('click', function() {
                deleteLabeledPixel(key, labelPixels[key]);
            });

            // Add a pin/marker at the center of the labeled pixel for better visibility
            const markerIcon = L.divIcon({
                html: `<div style="
                    width: 12px;
                    height: 12px;
                    background: ${labelColor};
                    border: 1px solid rgba(0,0,0,0.3);
                    border-radius: 50%;
                    box-shadow: 0 0 6px rgba(0,0,0,0.4);
                "></div>`,
                iconSize: [12, 12],
                className: 'labeled-pixel-marker'
            });

            const marker = L.marker([lat, lon], {
                icon: markerIcon,
                title: label
            }).addTo(maps.embedding);

            // Bind popup to marker
            marker.bindPopup(popupContent);

            // Hover behavior for marker
            marker.on('mouseover', function() {
                this.openPopup();
            });
            marker.on('mouseout', function() {
                this.closePopup();
            });

            // Click to delete
            marker.on('click', function(e) {
                L.DomEvent.stopPropagation(e);  // Prevent map click
                deleteLabeledPixel(key, labelPixels[key]);
            });

            // Store references to visual elements in labelPixels for deletion
            labelPixels[key].rectangle = rectangle;
            labelPixels[key].marker = marker;
        }

        // Update label count display
        function updateLabelCount() {
            let totalEmbeddings = 0;
            Object.values(embeddingLabels).forEach(embs => {
                totalEmbeddings += embs.length;
            });
            document.getElementById('label-count').textContent =
                `Labels: ${definedLabels.length} | Embeddings: ${totalEmbeddings}`;
        }

        // Export labels to JSON file
        function exportLabelsJSON() {
            if (definedLabels.length === 0 || Object.values(embeddingLabels).every(e => e.length === 0)) {
                alert('No labeled embeddings to export!');
                return;
            }

            // Build export data sorted by label name
            const exportData = definedLabels.map(label => ({
                label: label,
                embedding: embeddingLabels[label]
            }));

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `embedding_labels_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log(`‚úì Exported ${definedLabels.length} labels with ${Object.values(embeddingLabels).reduce((sum, e) => sum + e.length, 0)} embeddings`);
        }

        // Import labels from JSON file
        function importLabelsJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    if (!Array.isArray(importData)) {
                        alert('Invalid file format. Expected array of label objects.');
                        return;
                    }

                    let totalEmbeddings = 0;
                    // Import each label
                    importData.forEach(item => {
                        const label = item.label;
                        const embeddings = item.embedding || [];

                        // Create label if it doesn't exist
                        if (!definedLabels.includes(label)) {
                            definedLabels.push(label);
                            embeddingLabels[label] = [];
                            console.log(`[IMPORT] Created new label: "${label}"`);
                        }

                        // Add embeddings
                        embeddingLabels[label].push(...embeddings);
                        totalEmbeddings += embeddings.length;

                        console.log(`[IMPORT] Added ${embeddings.length} embeddings to "${label}"`);
                    });
                    // Sort labels alphabetically
                    definedLabels.sort();
                    // Update label dropdown using the standard function                    updateLabelDropdown();
                    // Update label count to show imported embeddings
                    updateLabelCount();

                    // Save to localStorage
                    saveLabels();

                    alert(`‚úì Successfully imported ${definedLabels.length} labels with ${totalEmbeddings} embeddings!`);
                    console.log(`‚úì Imported ${definedLabels.length} labels with ${totalEmbeddings} total embeddings`);

                } catch (error) {
                    alert(`Error importing labels: ${error.message}`);
                    console.error('Import error:', error);
                }

                // Reset file input
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // =====================================================================
        // SIMILARITY SEARCH FUNCTIONS
        // =====================================================================

        // Update threshold display when slider changes
        // Panel layout: 3 or 6 panels
        function setPanelLayout(numPanels) {
            const container = document.getElementById('map-container');
            const select = document.getElementById('panel-layout-select');

            if (numPanels === '6' || numPanels === 6) {
                container.classList.remove('three-panel');
                select.value = '6';
            } else {
                container.classList.add('three-panel');
                select.value = '3';
            }

            // Leaflet maps and Three.js scene need resize after container resize
            setTimeout(() => {
                Object.values(maps).forEach(map => {
                    if (map && map.invalidateSize) {
                        map.invalidateSize();
                    }
                });
                // Resize Three.js scene (Panel 4)
                if (umapCanvasLayer && umapCanvasLayer.resize) {
                    umapCanvasLayer.resize();
                }
            }, 350);  // Wait for CSS transition

            // Save preference
            localStorage.setItem('panelMode', numPanels.toString());
        }

        // Restore panel mode preference on load
        function restorePanelMode() {
            const container = document.getElementById('map-container');
            const select = document.getElementById('panel-layout-select');
            const saved = localStorage.getItem('panelMode');

            if (saved === '6') {
                // User prefers 6 panels
                container.classList.remove('three-panel');
                select.value = '6';
            } else {
                // Default to 3 panels
                container.classList.add('three-panel');
                select.value = '3';
            }
        }

        function updateThresholdDisplay() {
            const slider = document.getElementById('similarity-threshold');
            const display = document.getElementById('threshold-display');
            // Map slider 0-25 to threshold 0.0-25.0
            // Embeddings are 128D float32; L2 distances: min=0, median=28, mean=27.36, max~=45
            const value = parseInt(slider.value);
            display.textContent = value.toFixed(2);

            // If we have cached search results, update visualization in real-time
            if (explorerResults) {
                updateExplorerVisualization();
            }
        }


        // Clear explorer results and visualization
        function clearExplorerResults() {
            if (explorerVisualization) {
                explorerVisualization.clearLayers();
                maps.rgb.removeLayer(explorerVisualization);
                explorerVisualization = null;
            }

            explorerCanvasLayer = null;
            explorerResults = null;

            // Hide stats overlay
            const statsEl = document.getElementById('explorer-stats-overlay');
            if (statsEl) statsEl.style.display = 'none';

            // Clear cross-panel triangle markers
            clearCrossPanelMarkers();

            // Clear UMAP highlight marker and similarity highlighting
            if (umapCanvasLayer) {
                umapCanvasLayer.setHighlight(null);
                if (umapCanvasLayer.clearSimilarityHighlight) {
                    umapCanvasLayer.clearSimilarityHighlight();
                }
            }

            // Clear search cache for persistent labels
            currentSearchCache = null;
            const saveLabelBtn = document.getElementById('save-label-btn');
            if (saveLabelBtn) {
                saveLabelBtn.disabled = true;
            }

            console.log('[EXPLORER] Results cleared');
        }

        // Show explorer loading overlay
        function showExplorerLoading() {
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'explorer-loading';
            loadingDiv.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8); padding: 20px 30px; border-radius: 8px;
                color: #FFD700; font-weight: 600; z-index: 700; font-size: 16px;
            `;
            loadingDiv.textContent = 'Exploring similarities...';
            document.getElementById('map-embedding').appendChild(loadingDiv);
        }

        // Hide explorer loading overlay
        function hideExplorerLoading() {
            const loadingDiv = document.getElementById('explorer-loading');
            if (loadingDiv) loadingDiv.remove();
        }

        // Explorer click handler - one-click similarity search
        async function explorerClick(lat, lon) {
            console.log(`[EXPLORER] Click detected at ${lat.toFixed(6)}, ${lon.toFixed(6)}`);

            // Clear previous results
            clearExplorerResults();

            // Show loading
            showExplorerLoading();

            try {
                if (!faissLocal) {
                    alert('FAISS data not loaded yet. Please wait for download to complete.');
                    return;
                }

                // Step 1: Extract embedding locally
                const t0 = performance.now();
                const embedding = localExtract(lat, lon);
                if (!embedding) {
                    console.error(`[EXPLORER] No embedding found at ${lat}, ${lon}`);
                    alert('No embedding found at this location.');
                    return;
                }

                // Step 2: Search similar locally with wide threshold for caching
                const cacheThreshold = 35.0;
                const matches = localSearchSimilar(embedding, cacheThreshold);
                const queryTime = performance.now() - t0;
                console.log(`[EXPLORER] Local search: ${matches.length} matches in ${queryTime.toFixed(1)}ms`);

                // Step 3: Cache results
                explorerResults = {
                    sourcePixel: {lat, lon},
                    sourceEmbedding: Array.from(embedding),
                    allMatches: matches,
                    queryTime: queryTime,
                    cacheThreshold: cacheThreshold
                };

                // Also cache for persistent label system
                currentSearchCache = {
                    sourcePixel: {lat, lon},
                    embedding: Array.from(embedding),
                    allMatches: matches,
                    threshold: parseInt(document.getElementById('similarity-threshold').value),
                    timestamp: Date.now()
                };

                // Enable save button
                const saveLabelBtn = document.getElementById('save-label-btn');
                if (saveLabelBtn) {
                    saveLabelBtn.disabled = false;
                }

                // Step 4: Visualize with current threshold
                updateExplorerVisualization();

            } catch (error) {
                console.error('[EXPLORER] Error:', error);
                alert('Explorer search failed. Check console.');
            } finally {
                hideExplorerLoading();
            }
        }

        // Update explorer visualization based on current threshold
        async function updateExplorerVisualization() {
            if (!explorerResults) {
                console.log('[EXPLORER] No explorer results cached');
                return;
            }

            const currentThreshold = parseFloat(document.getElementById('threshold-display').textContent);
            // If threshold exceeds cache, re-search locally with wider threshold
            if (currentThreshold > explorerResults.cacheThreshold && faissLocal) {
                const embedding = explorerResults.sourceEmbedding instanceof Float32Array
                    ? explorerResults.sourceEmbedding
                    : new Float32Array(explorerResults.sourceEmbedding);
                const matches = localSearchSimilar(embedding, currentThreshold);
                explorerResults.allMatches = matches;
                explorerResults.cacheThreshold = currentThreshold;
            }

            // Filter cached results by current threshold
            const filteredMatches = explorerResults.allMatches.filter(m => m.distance <= currentThreshold);
            // Visualize filtered results
            visualizeExplorerResults(filteredMatches);

            // Update stats
            updateExplorerStats(filteredMatches, currentThreshold);
        }

        // Update explorer stats display
        function updateExplorerStats(matches, threshold) {
            let statsEl = document.getElementById('explorer-stats-overlay');
            if (!statsEl) {
                statsEl = document.createElement('div');
                statsEl.id = 'explorer-stats-overlay';
                statsEl.style.cssText = `
                    position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
                    background: rgba(0,0,0,0.85); color: #FFD700; padding: 8px 16px;
                    border-radius: 6px; font-size: 14px; font-weight: 600;
                    z-index: 600; pointer-events: none; white-space: nowrap;
                    backdrop-filter: blur(5px);
                `;
                document.getElementById('map-embedding').appendChild(statsEl);
            }
            const total = faissLocal ? faissLocal.numVectors : 0;
            const pct = total > 0 ? (matches.length / total * 100).toFixed(1) : '0.0';
            statsEl.textContent = `${matches.length.toLocaleString()} pixels (${pct}%) at threshold ${threshold.toFixed(1)}`;
            statsEl.style.display = 'block';
        }

        // Visualize explorer results with adaptive rendering
        function visualizeExplorerResults(matches) {
            if (matches.length === 0) {
                console.log('[EXPLORER] No matches to visualize');
                // Clear Panel 4 highlighting if no matches
                if (umapCanvasLayer && umapCanvasLayer.clearSimilarityHighlight) {
                    umapCanvasLayer.clearSimilarityHighlight();
                }
                return;
            }

            // If canvas layer exists (slider change), just update matches
            if (explorerCanvasLayer) {
                explorerCanvasLayer.updateMatches(matches);
            } else {
                // New search: create canvas layer and layer group
                const layerGroup = L.layerGroup();

                // Create and add canvas layer to RGB (Bing satellite) panel
                explorerCanvasLayer = new DirectCanvasLayer(matches, maps.rgb);
                layerGroup.addLayer(explorerCanvasLayer);

                // Add to RGB panel with 50% opacity
                layerGroup.addTo(maps.rgb);
                explorerVisualization = layerGroup;

                // Add source pixel marker to RGB panel
                visualizeSourcePixel(explorerResults.sourcePixel.lat, explorerResults.sourcePixel.lon, layerGroup);
            }

            // Also highlight matches in Panel 4 (PCA/UMAP)
            if (umapCanvasLayer && umapCanvasLayer.highlightSimilarPoints) {
                umapCanvasLayer.highlightSimilarPoints(matches);
            }
        }

// Custom canvas layer for direct pixel rendering
        class DirectCanvasLayer extends L.Layer {
            constructor(matches, map) {
                super();
                this.matches = matches;
                this._map = map;
                this._canvas = null;
                this._ctx = null;
                // Compute max distance for opacity scaling
                this._maxDistance = 1;
                this._updateMaxDistance();
            }

            _updateMaxDistance() {
                let maxDist = 0;
                for (const m of this.matches) {
                    if (m.distance > maxDist) maxDist = m.distance;
                }
                this._maxDistance = maxDist || 1;
            }

            onAdd(map) {
                this._map = map;

                // Create canvas element directly in map container
                this._canvas = document.createElement('canvas');
                this._canvas.className = 'explorer-direct-canvas';
                this._canvas.style.position = 'absolute';
                this._canvas.style.top = '0';
                this._canvas.style.left = '0';
                this._canvas.style.pointerEvents = 'none';
                this._canvas.style.zIndex = '999';

                const mapContainer = map.getContainer();
                mapContainer.appendChild(this._canvas);

                this._ctx = this._canvas.getContext('2d');
                this._updateCanvasSize();

                // Redraw on any map change
                this._map.on('move zoom resize', this._redraw, this);

                this._redraw();
            }

            onRemove(map) {
                this._map.off('move zoom resize', this._redraw, this);

                if (this._canvas) {
                    this._canvas.remove();
                }
            }

            _updateCanvasSize() {
                const size = this._map.getSize();
                this._canvas.width = size.x;
                this._canvas.height = size.y;
                this._canvas.style.width = size.x + 'px';
                this._canvas.style.height = size.y + 'px';
                this._ctx.imageSmoothingEnabled = false;
            }

            _redraw() {
                if (!this._ctx || !this._canvas) return;

                const ctx = this._ctx;
                const map = this._map;
                const size = map.getSize();

                // Clear canvas
                ctx.clearRect(0, 0, size.x, size.y);

                let visibleCount = 0;
                const maxDist = this._maxDistance;

                // Draw each pixel with overlap to eliminate banding from rounding errors
                const OVERLAP = 1.0;  // Pixels overlap by 1px to hide seams from coordinate rounding

                for (const match of this.matches) {
                    const matchBounds = calculatePixelBounds(match.lat, match.lon);
                    const sw = map.latLngToContainerPoint(matchBounds[0]);
                    const ne = map.latLngToContainerPoint(matchBounds[1]);

                    // Skip if completely off-screen
                    if (ne.x < 0 || sw.x > size.x || sw.y < 0 || ne.y > size.y) {
                        continue;
                    }

                    visibleCount++;

                    const alpha = 0.7;
                    ctx.fillStyle = `rgba(255, 255, 0, ${alpha.toFixed(3)})`;

                    // Calculate exact bounds without rounding, let canvas handle rendering
                    const x = sw.x - OVERLAP;
                    const y = ne.y - OVERLAP;
                    const width = ne.x - sw.x + 2 * OVERLAP;
                    const height = sw.y - ne.y + 2 * OVERLAP;

                    // Only draw if size is reasonable (avoid zero/negative sizes)
                    if (width > 0.1 && height > 0.1) {
                        ctx.fillRect(x, y, width, height);
                    }
                }

            }

            updateMatches(newMatches) {
                this.matches = newMatches;
                this._updateMaxDistance();
                this._redraw();
            }
        }

        // Visualize source pixel with distinct marker
        function visualizeSourcePixel(lat, lon, layerGroup) {
            const sourceMarker = L.marker([lat, lon], { icon: TRIANGLE_ICON });

            // Add to layer group
            if (layerGroup) {
                layerGroup.addLayer(sourceMarker);
            }
        }

        // Calculate average embedding from array of embeddings
        function calculateAverageEmbedding(embeddings) {
            if (embeddings.length === 0) return null;

            const dim = embeddings[0].length;
            const avgEmb = new Array(dim).fill(0);

            // Sum all embeddings
            for (let emb of embeddings) {
                for (let i = 0; i < dim; i++) {
                    avgEmb[i] += emb[i];
                }
            }

            // Divide by count - keep as float32, don't clamp!
            // Embeddings are float32 values (e.g., -2.5, 5.8, 1.3), not uint8 (0-255)
            for (let i = 0; i < dim; i++) {
                avgEmb[i] = avgEmb[i] / embeddings.length;
            }            return avgEmb;
        }

        // ===== PROGRESS TRACKING =====
        let progressPollInterval = null;

        function showProgressModal(title) {
            console.log(`[PROGRESS] Starting operation: ${title}`);
            document.getElementById('progress-title').textContent = title;
            document.getElementById('progress-overlay').classList.add('active');
        }

        function hideProgressModal() {
            console.log('[PROGRESS] Hiding progress modal');
            document.getElementById('progress-overlay').classList.remove('active');

            if (progressPollInterval) {
                clearInterval(progressPollInterval);
                progressPollInterval = null;
            }
        }

        function updateProgressUI(data) {
            // Update message
            document.getElementById('progress-message').textContent = data.message || '';

            // Update current file
            const fileEl = document.getElementById('progress-file');
            if (data.current_file) {
                fileEl.textContent = `File: ${data.current_file}`;
                fileEl.style.display = 'block';
            } else {
                fileEl.style.display = 'none';
            }

            // Update progress bar
            const percent = data.percent || 0;
            const progressBar = document.getElementById('progress-bar');
            const progressBarText = document.getElementById('progress-bar-text');
            progressBar.style.width = percent + '%';
            if (percent > 0) {
                progressBarText.textContent = percent + '%';
            }

            // Update percent display
            document.getElementById('progress-percent').textContent = percent + '%';

            // Update status
            const statusEl = document.getElementById('progress-status');
            statusEl.textContent = (data.status || 'processing').toUpperCase();
            statusEl.className = 'progress-status ' + (data.status || 'processing');
        }

        async function pollOperationProgress(operationId, title) {
            showProgressModal(title);

            let isComplete = false;

            progressPollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/operations/progress/${operationId}`);
                    const result = await response.json();

                    if (result.success && result.status) {
                        const data = result;
                        updateProgressUI(data);

                        console.log(`[PROGRESS] ${operationId}: ${data.message} (${data.percent}%)`);

                        // Check if operation is complete or failed
                        if (data.status === 'complete' || data.status === 'error') {
                            isComplete = true;

                            // Show final message for 2 seconds
                            setTimeout(() => {
                                hideProgressModal();
                            }, 2000);

                            // Clear interval
                            clearInterval(progressPollInterval);
                            progressPollInterval = null;
                        }
                    }
                } catch (error) {
                    console.error('[PROGRESS] Error polling progress:', error);
                    // Continue polling even if there's an error
                }
            }, 500); // Poll every 500ms
        }

        // ===== END PROGRESS TRACKING =====

        // ===== UMAP: Three.js scene class is defined in the <script type="module"> block near </body> =====
        // UMAPScene is attached to window by that module and used here via window.UMAPScene.

        class HeatmapCanvasLayer extends L.Layer {
            constructor(distances, stats = null) {
                super();
                this.distances = distances;  // [{lat, lon, distance}, ...]
                this._canvas = null;
                this._ctx = null;

                // Use percentile-based normalization for better color distribution
                // Instead of max distance, use 95th percentile to avoid outliers compressing the scale
                if (stats && stats.max_distance > 0) {
                    // Estimate 95th percentile from stats (use mean + 2*std as approximation)
                    // For now, use max distance but scale it by median to get better distribution
                    const median = stats.median_distance || stats.mean_distance;

                    // Use 75th percentile as scale (roughly median + 0.67*std)
                    // This spreads the common range (below median) across more of the color scale
                    this.maxDistance = median * 1.5;  // Scale by 1.5x median for better gradient spread

                    console.log('Heatmap distance scale:', {
                        actual_max: stats.max_distance.toFixed(3),
                        median: median.toFixed(3),
                        scale_to: this.maxDistance.toFixed(3)
                    });
                } else {
                    // Fallback: calculate maxDistance locally
                    let maxDist = 0;
                    for (let i = 0; i < distances.length; i++) {
                        if (distances[i].distance > maxDist) {
                            maxDist = distances[i].distance;
                        }
                    }
                    this.maxDistance = maxDist > 0 ? maxDist : 1;
                }

                // Sample and log distance values for debugging
                if (distances && distances.length > 0) {
                    const sampleDistances = distances.slice(0, 5).map(d => d.distance.toFixed(3));
                }
            }

            onAdd(map) {
                this._map = map;

                // Create canvas
                this._canvas = document.createElement('canvas');
                this._canvas.style.position = 'absolute';
                this._canvas.style.top = '0';
                this._canvas.style.left = '0';
                this._canvas.style.opacity = '1.0';  // Full opacity for vivid color display
                this._canvas.style.pointerEvents = 'none';  // Allow clicks to pass through

                // Insert at START of container so Leaflet panes (including markers) render on top
                const container = map.getContainer();
                container.insertBefore(this._canvas, container.firstChild);

                this._ctx = this._canvas.getContext('2d');


                map.on('move zoom resize', () => this._redraw());
                this._redraw();
            }

            onRemove(map) {
                map.off('move zoom resize', () => this._redraw());
                if (this._canvas && this._canvas.parentNode) {
                    this._canvas.parentNode.removeChild(this._canvas);
                }
            }

            _redraw() {
                // Guard: only redraw if map is initialized
                if (!this._map || !this._canvas || !this._ctx) return;

                const size = this._map.getSize();

                // Set canvas pixel dimensions AND CSS display dimensions to match
                this._canvas.width = size.x;
                this._canvas.height = size.y;
                this._canvas.style.width = size.x + 'px';
                this._canvas.style.height = size.y + 'px';

                // Re-enable image smoothing after setting canvas dimensions (which resets context state)
                this._ctx.imageSmoothingEnabled = true;

                // Clear with transparent background
                this._ctx.clearRect(0, 0, size.x, size.y);

                let pixelsDrawn = 0;
                const colors = new Set();

                // Draw each pixel with color based on distance (no sorting to preserve 2D layout)
                for (const d of this.distances) {
                    const bounds = calculatePixelBounds(d.lat, d.lon);
                    const sw = this._map.latLngToContainerPoint(bounds[0]);
                    const ne = this._map.latLngToContainerPoint(bounds[1]);

                    // Calculate pixel position and size
                    const x = Math.floor(sw.x);
                    const width = Math.ceil(ne.x - sw.x) + 1;
                    const y = Math.floor(ne.y);
                    const height = Math.ceil(sw.y - ne.y) + 1;

                    // Skip off-screen pixels
                    if (x + width < 0 || x > size.x || y + height < 0 || y > size.y) {
                        continue;
                    }

                    // Viridis color gradient: purple/blue (0) -> green -> yellow (max)
                    const normalized = d.distance / this.maxDistance;
                    const color = this.getHeatmapColor(normalized);
                    colors.add(color);

                    this._ctx.fillStyle = color;
                    this._ctx.fillRect(x, y, width, height);
                    pixelsDrawn++;
                }

                // Log detailed heatmap rendering info
                if (pixelsDrawn > 0) {
                    if (colors.size > 0) {
                        const colorArray = Array.from(colors).slice(0, 5);
                    }
                } else {
                }
            }

            getHeatmapColor(value) {
                // Viridis colormap - perceptually uniform
                // value: 0 (dark purple/blue) -> 0.5 (green) -> 1.0 (bright yellow)
                // Based on https://viridis.scijs.org/

                const viridis = [
                    [68, 1, 84],      // 0.00: dark purple
                    [72, 40, 120],    // 0.17
                    [62, 74, 137],    // 0.33: blue
                    [47, 105, 141],   // 0.50: teal
                    [39, 133, 133],   // 0.67: cyan-green
                    [92, 156, 89],    // 0.83: green
                    [181, 172, 39],   // 1.00: yellow
                ];

                // Clamp value to 0-1 range
                const clampedValue = Math.max(0, Math.min(1, value));

                // Normalize value to viridis array index (0-6)
                const idx = clampedValue * (viridis.length - 1);
                const lowerIdx = Math.floor(idx);
                const upperIdx = Math.ceil(idx);
                const fraction = idx - lowerIdx;

                // Interpolate between two nearest colors
                const lower = viridis[Math.min(lowerIdx, viridis.length - 1)];
                const upper = viridis[Math.min(upperIdx, viridis.length - 1)];

                const r = Math.floor(lower[0] * (1 - fraction) + upper[0] * fraction);
                const g = Math.floor(lower[1] * (1 - fraction) + upper[1] * fraction);
                const b = Math.floor(lower[2] * (1 - fraction) + upper[2] * fraction);

                return `rgb(${r}, ${g}, ${b})`;
            }

            updateDistances(newDistances) {
                this.distances = newDistances;

                // Calculate maxDistance without spread operator for large arrays
                let maxDist = 0;
                for (let i = 0; i < newDistances.length; i++) {
                    if (newDistances[i].distance > maxDist) {
                        maxDist = newDistances[i].distance;
                    }
                }
                this.maxDistance = maxDist > 0 ? maxDist : 1;
                this._redraw();
            }
        }

        // ===== END UMAP AND HEATMAP LAYERS =====

        // ===== UMAP AND HEATMAP LOADING FUNCTIONS =====

        // Load dimensionality reduction (PCA or UMAP) with background computation if needed
        async function loadDimReduction(method = null) {
            // Use specified method or current selection
            const dimMethod = method || currentDimReduction;
            const methodUpper = dimMethod.toUpperCase();

            try {
                console.log(`[${methodUpper}] Checking status for ${currentViewportName}/${currentEmbeddingYear}...`);

                // Update panel title
                const titleEl = document.getElementById('panel4-title');
                if (titleEl) {
                    titleEl.textContent = `${methodUpper} (Embedding Space)`;
                }

                // Check if method needs to be computed
                let statusResp = await fetch(`/api/viewports/${currentViewportName}/${dimMethod}-status?year=${currentEmbeddingYear}`);
                let status = await statusResp.json();

                // If waiting for embeddings (FAISS still running), poll until ready
                if (status.waiting) {
                    console.log(`[${methodUpper}] Waiting for embeddings (FAISS indexing in progress)...`);
                    const umapContainer = document.getElementById('map-umap');
                    umapContainer.innerHTML = `<div id="umap-progress" style="display:flex;align-items:center;justify-content:center;height:100%;font-size:18px;color:#666;">‚è≥ ${status.message || 'Waiting for data...'}</div>`;

                    // Poll until embeddings are ready
                    while (status.waiting) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        statusResp = await fetch(`/api/viewports/${currentViewportName}/${dimMethod}-status?year=${currentEmbeddingYear}`);
                        status = await statusResp.json();
                    }
                    console.log(`[${methodUpper}] Embeddings ready, proceeding...`);
                }

                if (status.computing || !status.exists) {
                    const waitMsg = dimMethod === 'pca' ? 'Computing PCA...' : 'Computing UMAP (this may take a few minutes)...';
                    console.log(`[${methodUpper}] ${status.computing ? 'Already computing' : 'Starting computation'}... (operation: ${status.operation_id})`);

                    // Show loading message in Panel 4
                    const umapContainer = document.getElementById('map-umap');
                    umapContainer.innerHTML = `<div id="umap-progress" style="display:flex;align-items:center;justify-content:center;height:100%;font-size:18px;color:#666;">‚è≥ ${waitMsg}</div>`;

                    // Poll until complete
                    await waitForDimReduction(status.operation_id, dimMethod);
                    console.log(`[${methodUpper}] Computation complete`);
                }

                // Load the coordinates (either already existed or just finished computing)
                console.log(`[${methodUpper}] Loading coordinates...`);
                const response = await fetch(`/api/viewports/${currentViewportName}/compute-${dimMethod}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({year: parseInt(currentEmbeddingYear)})
                });

                const data = await response.json();
                if (data.success) {
                    console.log(`[${methodUpper}] Got ${data.num_points} points, initializing Three.js scene...`);
                    umapData = data.points;

                    // Destroy previous scene if reloading
                    if (umapCanvasLayer) {
                        umapCanvasLayer.dispose();
                        umapCanvasLayer = null;
                    }

                    umapCanvasLayer = new window.UMAPScene('map-umap', umapData);

                    // Ensure correct size after layout
                    setTimeout(() => {
                        if (umapCanvasLayer && umapCanvasLayer.resize) {
                            umapCanvasLayer.resize();
                        }
                    }, 50);

                    // Apply labels if they were loaded before
                    if (savedLabels && savedLabels.length > 0) {
                        console.log(`[${methodUpper}] Applying ${savedLabels.length} labels to colors...`);
                        updateUMAPColorsFromLabels();
                        console.log(`‚úì ${methodUpper} rendered: ${data.num_points} points (colored by labels)`);
                    } else {
                        console.log(`‚úì ${methodUpper} rendered: ${data.num_points} points (all grey)`);
                    }
                } else {
                    console.error(`[${methodUpper}] Error: ${data.error}`);
                    const umapContainer = document.getElementById('map-umap');
                    umapContainer.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;height:100%;font-size:16px;color:#e74c3c;">Error: ${data.error}</div>`;
                }
            } catch (error) {
                console.error(`[${methodUpper}] Fatal error:`, error);
            }
        }

        // Backward-compatible alias
        async function loadUMAP() {
            await loadDimReduction(currentDimReduction);
        }

        // Poll for dimensionality reduction completion with progress updates
        async function waitForDimReduction(operationId, method = 'umap') {
            const methodUpper = method.toUpperCase();
            return new Promise(resolve => {
                const poll = async () => {
                    try {
                        const resp = await fetch(`/api/operations/progress/${operationId}`);
                        const prog = await resp.json();

                        // Update progress display
                        const progressDiv = document.getElementById('umap-progress');
                        if (progressDiv && prog.percent !== undefined) {
                            const message = prog.message || `Computing ${methodUpper}`;
                            progressDiv.textContent = `‚è≥ ${message} (${prog.percent}%)`;
                        }

                        if (prog.status === 'complete' || prog.status === 'error') {
                            resolve();
                        } else {
                            setTimeout(poll, 500);  // Poll faster for PCA (it's quick)
                        }
                    } catch (e) {
                        setTimeout(poll, 1000);
                    }
                };
                poll();
            });
        }

        // Backward-compatible alias
        async function waitForUMAP(operationId) {
            return waitForDimReduction(operationId, 'umap');
        }

        // Update heatmap message visibility based on year comparison
        function updateHeatmapMessage() {
            const messageDiv = document.getElementById('heatmap-same-year-message');
            if (!messageDiv) return;

            if (currentEmbeddingYear === currentEmbeddingYear2) {
                // Years are the same - show message
                messageDiv.style.display = 'block';
            } else {
                // Years are different - hide message and load heatmap
                messageDiv.style.display = 'none';
            }
        }

        // Load distance heatmap for Panel 5
        async function loadHeatmap() {
            // Check if years are the same and show/hide message
            updateHeatmapMessage();

            // If years are the same, don't load heatmap
            if (currentEmbeddingYear === currentEmbeddingYear2) {
                return;
            }

            try {
                const zoom = maps.heatmap.getZoom();
                const response = await fetch('/api/embeddings/distance-heatmap', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        viewport_id: currentViewportName,
                        year1: parseInt(currentEmbeddingYear),
                        year2: parseInt(currentEmbeddingYear2),
                        zoom: zoom
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Remove old heatmap layer
                    if (heatmapCanvasLayer && maps.heatmap.hasLayer(heatmapCanvasLayer)) {
                        maps.heatmap.removeLayer(heatmapCanvasLayer);
                    }

                    // Create new heatmap layer with backend statistics for proper normalization
                    heatmapCanvasLayer = new HeatmapCanvasLayer(data.distances, data.stats);
                    heatmapCanvasLayer.addTo(maps.heatmap);

                    // Log distance statistics from backend
                    if (data.stats) {
                        console.log(`‚úì Heatmap loaded: ${data.distances.length} distances (${data.stats.matched} matched)`);
                        console.log(`  Distance range: ${data.stats.min_distance.toFixed(3)} to ${data.stats.max_distance.toFixed(3)} (mean: ${data.stats.mean_distance.toFixed(3)}, median: ${data.stats.median_distance.toFixed(3)})`);
                    } else {
                        console.log(`‚úì Heatmap loaded: ${data.distances.length} distances`);
                    }
                } else {
                }
            } catch (error) {
            }
        }

        // Highlight a point in the UMAP scene by geographic lat/lon
        function highlightUMAPPoint(lat, lon) {
            if (!umapData || !umapCanvasLayer) return;

            // Find the nearest UMAP point to clicked geographic location
            let nearest = null;
            let minDist = Infinity;

            for (const point of umapData) {
                const dist = Math.pow(point.lat - lat, 2) + Math.pow(point.lon - lon, 2);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = point;
                }
            }

            if (!nearest) return;
            umapCanvasLayer.setHighlight(nearest);
        }

        // Show distance at a point in heatmap
        function showDistanceAtPoint(lat, lon) {
            if (!heatmapCanvasLayer || !heatmapCanvasLayer.distances) return;

            // Find closest distance point
            let closest = null;
            let minDist = Infinity;

            for (const d of heatmapCanvasLayer.distances) {
                const dist = Math.sqrt((d.lat - lat) ** 2 + (d.lon - lon) ** 2);
                if (dist < minDist) {
                    minDist = dist;
                    closest = d;
                }
            }

            if (closest && minDist < 0.0001) {  // Within ~10m
                console.log(`Distance at (${lat.toFixed(6)}, ${lon.toFixed(6)}): ${closest.distance.toFixed(3)}`);
                alert(`Embedding distance: ${closest.distance.toFixed(3)}\nLocation: (${lat.toFixed(6)}, ${lon.toFixed(6)})`);
            }
        }

        // Update UMAP colors when labels are saved
        function updateUMAPColorsFromLabels() {
            if (umapCanvasLayer && savedLabels) {
                umapCanvasLayer.updateLabelColors(savedLabels);
            }
        }

        // ===== END UMAP AND HEATMAP FUNCTIONS =====

        // Poll for FAISS index and show labeling controls when available
        function startFAISSPolling() {
            const checkFAISS = async () => {
                try {
                    const response = await fetch(`/api/viewports/${currentViewportName}/available-years`);
                    const data = await response.json();
                    if (data.success && data.years && data.years.length > 0) {
                        // Check if FAISS index exists for any year
                        const faissCheckResp = await fetch(`/api/viewports/${currentViewportName}/is-ready`);
                        const faissStatus = await faissCheckResp.json();
                        if (faissStatus.has_faiss) {
                            // FAISS ready on server ‚Äî download data for client-side search
                            const year = currentEmbeddingYear || data.years[0];
                            console.log(`[FAISS-LOCAL] Server FAISS ready, downloading data for ${currentViewportName}/${year}...`);
                            try {
                                await downloadFaissData(currentViewportName, year);
                            } catch (e) {
                                console.error('[FAISS-LOCAL] Download failed:', e);
                            }
                            // Show labeling controls after local data is cached
                            document.getElementById('label-controls-bar').style.display = 'flex';
                            console.log('[ADVANCED VIEWER] Local FAISS data ready - labeling enabled');
                            // Recompute labels now that local data is available
                            if (savedLabels.length > 0) {
                                await recomputeLabelPixels();
                            }
                            return; // Stop polling
                        }
                    }
                    // FAISS not ready yet, poll again
                    setTimeout(checkFAISS, 2000);
                } catch (error) {
                    // Poll again on error
                    setTimeout(checkFAISS, 2000);
                }
            };
            checkFAISS();
        }

        // Initialize
        window.onload = async function() {
            // Fetch tile server URL from backend config
            try {
                const configResp = await fetch('/api/config');
                const config = await configResp.json();
                if (config.tile_server) {
                    TILE_SERVER = config.tile_server;
                    console.log('Tile server:', TILE_SERVER);
                }
            } catch (e) {
                console.warn('Failed to fetch config, using default tile server:', e);
            }

            // Load viewport info first (determines map center/zoom)
            await updateMapViewport();

            // Check if any background operations are still running (silently, no progress bar)
            if (currentViewportName) {
                checkOperationStatusSilently(currentViewportName);
            }

            // Then create maps with correct viewport
            createMaps();
            restorePanelMode();  // Restore 3/6 panel preference

            // Invalidate map sizes after layout is applied
            setTimeout(() => {
                Object.values(maps).forEach(map => {
                    if (map && map.invalidateSize) {
                        map.invalidateSize();
                    }
                });
                // Also resize Three.js scene (Panel 4)
                if (umapCanvasLayer && umapCanvasLayer.resize) {
                    umapCanvasLayer.resize();
                }
            }, 100);

            await loadAvailableYears();  // Panel 3: Load year selector
            await loadAvailableYears2(); // Panel 6: Load second year selector
            loadLabels();
            await loadSavedLabels();  // Load label definitions from localStorage, recompute pixels from FAISS
            updateThresholdDisplay();  // Initialize threshold display

            // Poll for FAISS index and show labeling controls when ready
            startFAISSPolling();

            // Set up dimensionality reduction selector (PCA/UMAP)
            const dimSelector = document.getElementById('dim-reduction-selector');
            if (dimSelector) {
                dimSelector.addEventListener('change', async (e) => {
                    currentDimReduction = e.target.value;
                    console.log(`[DimReduction] Switching to ${currentDimReduction.toUpperCase()}`);
                    await loadDimReduction(currentDimReduction);
                });
            }

            // Initialize new panels (default to PCA for speed)
            await loadDimReduction('pca');  // Panel 4: PCA visualization (fast)
            await loadHeatmap();            // Panel 5: Distance heatmap

            // Check tile server health
            fetch(`${TILE_SERVER}/health`)
                .then(resp => resp.json())
                .then(data => {
                    console.log('Tile server status:', data);
                })
                .catch(err => {
                    console.warn('Tile server not responding:', err);
                    alert(`Warning: Tile server not responding (${TILE_SERVER}). Run restart.sh if local.`);
                });
        };

        // Handle window resize - invalidate all Leaflet maps and Three.js scene
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Invalidate all Leaflet maps so they resize properly
                Object.values(maps).forEach(map => {
                    if (map && map.invalidateSize) {
                        map.invalidateSize();
                    }
                });
                // Resize Three.js scene (Panel 4)
                if (umapCanvasLayer && umapCanvasLayer.resize) {
                    umapCanvasLayer.resize();
                }
            }, 100);  // Debounce to avoid excessive calls
        });

        // Check for ongoing operations and start polling if found
        async function checkAndPollOperations(viewportId) {
            const operations = ['embeddings', 'pyramids', 'faiss'];

            for (const op of operations) {
                const operationId = `${viewportId}_${op}`;
                try {
                    const response = await fetch(`/api/operations/progress/${operationId}`);
                    const result = await response.json();

                    if (result.success && result.status && result.status !== 'complete') {
                        console.log(`[PROGRESS] Found ongoing operation: ${operationId}`);
                        const titles = {
                            'embeddings': 'üì• Downloading Embeddings',
                            'pyramids': 'üî® Creating Pyramids',
                            'faiss': 'üîç Building FAISS Index'
                        };
                        await pollOperationProgress(operationId, titles[op]);
                        // Poll the next operation after this one completes
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                } catch (error) {
                    // Operation not found or error checking - continue to next operation
                }
            }
        }

        // Check operation status silently (no progress bar, just logging)
        async function checkOperationStatusSilently(viewportId) {
            try {
                const response = await fetch(`/api/operations/pipeline-status/${viewportId}`);
                const result = await response.json();

                if (result.success) {
                    if (result.status === 'success') {
                        console.log(`[STATUS] ‚úì ${viewportId} pipeline completed successfully`);
                        // Clear any stale processing message
                        hideProgressModal();
                    } else if (result.status === 'failed') {
                        console.error(`[STATUS] ‚úó ${viewportId} pipeline failed: ${result.error}`);
                        hideProgressModal();
                    } else if (result.status === 'in_progress') {
                        console.log(`[STATUS] ‚è≥ ${viewportId} still processing: ${result.current_stage}`);
                    }
                }
            } catch (error) {
                // Silent fail - operation might not exist yet
            }
        }

        // ===== PERSISTENT LABEL SYSTEM =====
        // Global variables for label management
        let savedLabels = [];  // Array of label objects (stored in localStorage)
        let currentSearchCache = null;  // Cache of current FAISS search results

        // Persist labels to localStorage (metadata only, no pixel arrays)
        function persistLabels() {
            const toStore = savedLabels.map(l => {
                const {pixels, visible, ...meta} = l;
                return meta;
            });
            localStorage.setItem('tee_labels_' + currentViewportName, JSON.stringify(toStore));
        }

        // Load saved labels from localStorage, then recompute pixels from FAISS
        async function loadSavedLabels() {
            try {
                const raw = localStorage.getItem('tee_labels_' + currentViewportName);
                savedLabels = raw ? JSON.parse(raw).map(l => ({...l, visible: true, pixels: []})) : [];
                updateLabelsUI();
                console.log(`‚úì Loaded ${savedLabels.length} label definitions from localStorage`);
                if (savedLabels.length > 0) {
                    await recomputeLabelPixels();
                }
            } catch (error) {
                console.error('Error loading labels:', error);
                savedLabels = [];
            }
        }

        // Recompute pixel coverage for all labels from FAISS index
        async function recomputeLabelPixels() {
            if (!faissLocal) {
                console.warn('[LABEL] FAISS data not loaded, skipping recompute');
                return;
            }
            for (const label of savedLabels) {
                try {
                    // Use stored embedding if available (exact match to original search),
                    // otherwise fall back to re-extracting from source pixel
                    let embedding = label.embedding;
                    if (embedding) {
                        // Convert from Array to Float32Array for localSearchSimilar
                        if (!(embedding instanceof Float32Array)) {
                            embedding = new Float32Array(embedding);
                        }
                    } else {
                        embedding = localExtract(label.source_pixel.lat, label.source_pixel.lon);
                        if (!embedding) {
                            console.warn(`[LABEL] No embedding for ${label.name} at source pixel`);
                            continue;
                        }
                        label.embedding = Array.from(embedding);
                    }
                    const matches = localSearchSimilar(embedding, label.threshold);
                    label.pixels = matches;
                    label.pixel_count = matches.length;
                } catch (error) {
                    console.error(`[LABEL] Error recomputing ${label.name}:`, error);
                }
            }
            persistLabels();
            updateOverlay();
        }

        // Update labels UI list
        let labelsExportedSinceChange = false;
        function updateLabelsUI() {
            const listEl = document.getElementById('labels-list');
            const countEl = document.getElementById('label-count');

            countEl.textContent = savedLabels.length;

            // Highlight export button and show warning when unexported labels exist
            const exportBtn = document.getElementById('export-dropdown-btn');
            const warning = document.getElementById('unsaved-labels-warning');
            if (savedLabels.length > 0 && !labelsExportedSinceChange) {
                exportBtn.classList.add('export-btn-highlight');
                warning.style.display = '';
            } else {
                exportBtn.classList.remove('export-btn-highlight');
                warning.style.display = 'none';
            }

            if (savedLabels.length === 0) {
                listEl.innerHTML = '<div style="color: #999; font-size: 12px; padding: 10px;">No labels yet. Click a pixel to search and save results.</div>';
                return;
            }

            // Group labels by name
            const groups = new Map();
            for (const label of savedLabels) {
                if (!groups.has(label.name)) {
                    groups.set(label.name, []);
                }
                groups.get(label.name).push(label);
            }

            listEl.innerHTML = Array.from(groups.entries()).map(([name, members]) => renderLabelGroup(name, members)).join('');

            // Attach event listeners
            listEl.querySelectorAll('.timeline-label-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const labelName = e.currentTarget.dataset.labelName;
                    showLabelTimeline(labelName);
                });
            });

            listEl.querySelectorAll('.toggle-label-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const labelName = e.currentTarget.dataset.labelName;
                    const members = savedLabels.filter(l => l.name === labelName);
                    members.forEach(l => toggleLabelVisibility(l.id, true));
                    updateOverlay();
                    updateLabelsUI();
                });
            });

            listEl.querySelectorAll('.delete-label-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const labelName = e.currentTarget.dataset.labelName;
                    deleteLabelGroup(labelName);
                });
            });
        }

        // Render grouped label card
        function renderLabelGroup(name, members) {
            const color = members[0].color;
            const totalPixels = members.reduce((sum, l) => sum + l.pixel_count, 0);
            const markerCount = members.length;
            const markerNote = markerCount > 1 ? ` (${markerCount} markers)` : '';
            return `
                <div class="label-item" style="padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; background: white; border-left: 4px solid ${color};">
                  <div style="display: flex; align-items: flex-start; justify-content: space-between;">
                    <div style="flex: 1;">
                      <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 14px; height: 14px; background: ${color}; border-radius: 2px; margin-right: 8px;"></div>
                        <div style="font-weight: 600; font-size: 13px; color: #333;">${name}${markerNote}</div>
                      </div>
                      <div style="font-size: 11px; color: #999; margin-left: 22px;">${totalPixels.toLocaleString()} pixels, threshold: ${members[0].threshold}</div>
                    </div>
                    <div style="display: flex; gap: 6px;">
                      <button class="timeline-label-btn" data-label-name="${name}" style="padding: 5px 8px; background: #f0f0ff; border: 1px solid #b0b0ff; border-radius: 3px; cursor: pointer; font-size: 12px; color: #5500cc; font-weight: 600;" title="Show coverage timeline across years">Timeline</button>
                      <button class="toggle-label-btn" data-label-name="${name}" style="padding: 5px 8px; background: #e8f0ff; border: 1px solid #b0d4ff; border-radius: 3px; cursor: pointer; font-size: 12px; color: #0066cc; font-weight: 600;" title="Toggle visibility">Show</button>
                      <button class="delete-label-btn" data-label-name="${name}" style="padding: 5px 8px; background: #ffe8e8; border: 1px solid #ffb0b0; border-radius: 3px; cursor: pointer; font-size: 12px; color: #cc0000; font-weight: 600;" title="Delete label">Delete</button>
                    </div>
                  </div>
                </div>
            `;
        }

        // Show save label modal
        function saveCurrentSearchAsLabel() {
            if (!currentSearchCache || currentSearchCache.allMatches.length === 0) {
                alert('No search results to save. Click a pixel first.');
                return;
            }

            // Clear form and show modal with a contrastive color
            const suggestedColor = nextLabelColor();
            document.getElementById('label-name-input').value = '';
            document.getElementById('label-color-input').value = suggestedColor;
            document.getElementById('color-hex-display').textContent = suggestedColor.toUpperCase();

            // Populate existing labels list
            const listContainer = document.getElementById('existing-labels-list');
            const rowsContainer = document.getElementById('existing-labels-rows');
            rowsContainer.innerHTML = '';

            // Collect unique name+color pairs from saved labels
            const seen = new Set();
            const uniqueLabels = [];
            for (const l of savedLabels) {
                const key = l.name + '|' + l.color;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueLabels.push({ name: l.name, color: l.color });
                }
            }

            if (uniqueLabels.length > 0) {
                listContainer.style.display = 'block';
                for (const ul of uniqueLabels) {
                    const row = document.createElement('div');
                    row.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 8px 10px; cursor: pointer; border-radius: 4px; border: 2px solid transparent; margin-bottom: 4px; background: #f5f5f5;';
                    row.innerHTML = `<span style="width: 18px; height: 18px; border-radius: 3px; background: ${ul.color}; border: 1px solid #999; flex-shrink: 0;"></span><span style="color: #333; font-size: 14px;">${ul.name}</span>`;
                    row.addEventListener('click', function() {
                        document.getElementById('label-name-input').value = ul.name;
                        document.getElementById('label-color-input').value = ul.color;
                        document.getElementById('color-hex-display').textContent = ul.color.toUpperCase();
                        // Highlight selected row
                        rowsContainer.querySelectorAll('div').forEach(r => r.style.borderColor = 'transparent');
                        row.style.borderColor = ul.color;
                    });
                    row.addEventListener('mouseenter', function() { row.style.background = '#e8e8e8'; });
                    row.addEventListener('mouseleave', function() { row.style.background = '#f5f5f5'; });
                    rowsContainer.appendChild(row);
                }
            } else {
                listContainer.style.display = 'none';
            }

            document.getElementById('save-label-modal-overlay').style.display = 'flex';
            document.getElementById('label-name-input').focus();
        }

        // Handle save label confirmation
        function confirmSaveLabel() {
            const name = document.getElementById('label-name-input').value.trim();
            const color = document.getElementById('label-color-input').value;

            if (!name) {
                alert('Please enter a label name');
                return;
            }

            // Get current threshold from slider
            const currentThreshold = parseFloat(document.getElementById('threshold-display').textContent);

            // Filter matches by current threshold
            const filteredMatches = currentSearchCache.allMatches.filter(m => m.distance <= currentThreshold);

            // Compute similarity statistics
            let minDist = Infinity, maxDist = -Infinity, sumDist = 0;
            for (const m of filteredMatches) {
                if (m.distance < minDist) minDist = m.distance;
                if (m.distance > maxDist) maxDist = m.distance;
                sumDist += m.distance;
            }
            const meanDist = sumDist / (filteredMatches.length || 1);

            const labelData = {
                id: 'label_' + Date.now(),
                name: name,
                color: color,
                threshold: currentThreshold,
                mean_distance: meanDist,
                min_distance: minDist,
                max_distance: maxDist,
                source_pixel: currentSearchCache.sourcePixel,
                embedding: currentSearchCache.embedding,
                pixel_count: filteredMatches.length,
                created: new Date().toISOString(),
                visible: true,
                pixels: filteredMatches.map(m => ({
                    lat: m.lat,
                    lon: m.lon,
                    distance: m.distance
                }))
            };

            savedLabels.push(labelData);
            labelsExportedSinceChange = false;
            persistLabels();
            updateLabelsUI();
            updateOverlay();

            // Clear the explorer preview (yellow overlay)
            clearExplorerResults();

            // Place persistent colored markers at the source pixel location on all panels
            const coloredIcon = makeColoredTriangleIcon(color);
            const srcLat = labelData.source_pixel.lat;
            const srcLon = labelData.source_pixel.lon;
            const entry = { labelId: labelData.id, markers: {} };
            ['osm', 'rgb', 'embedding', 'heatmap', 'embedding2'].forEach(key => {
                if (maps[key]) {
                    entry.markers[key] = L.marker([srcLat, srcLon], { icon: coloredIcon })
                        .bindTooltip(name, { direction: 'top', offset: [0, -20] })
                        .addTo(maps[key]);
                }
            });
            persistentLabelMarkers.push(entry);

            closeSaveLabelModal();
            console.log(`‚úì Saved label: ${name} (${labelData.pixel_count} pixels)`);
        }

        // Close save label modal
        function closeSaveLabelModal() {
            document.getElementById('save-label-modal-overlay').style.display = 'none';
        }

        // Delete a saved label
        function deleteSavedLabel(labelId) {
            if (!confirm('Delete this label?')) return;

            savedLabels = savedLabels.filter(l => l.id !== labelId);
            labelsExportedSinceChange = false;

            // Remove persistent markers for this label
            persistentLabelMarkers = persistentLabelMarkers.filter(entry => {
                if (entry.labelId === labelId) {
                    for (const key of Object.keys(entry.markers)) {
                        if (entry.markers[key] && maps[key]) maps[key].removeLayer(entry.markers[key]);
                    }
                    return false;
                }
                return true;
            });

            persistLabels();
            updateLabelsUI();
            updateOverlay();
            console.log(`‚úì Deleted label: ${labelId}`);
        }

        // Toggle label visibility (silent=true skips UI refresh, for batch use)
        function toggleLabelVisibility(labelId, silent) {
            const label = savedLabels.find(l => l.id === labelId);
            if (label) {
                label.visible = !label.visible;
                if (!silent) {
                    updateOverlay();
                    updateLabelsUI();
                }
            }
        }

        // Delete all labels with a given name
        function deleteLabelGroup(name) {
            const members = savedLabels.filter(l => l.name === name);
            if (!confirm(`Delete "${name}" (${members.length} marker${members.length > 1 ? 's' : ''})?`)) return;
            const ids = new Set(members.map(l => l.id));
            savedLabels = savedLabels.filter(l => !ids.has(l.id));
            labelsExportedSinceChange = false;
            persistentLabelMarkers = persistentLabelMarkers.filter(entry => {
                if (ids.has(entry.labelId)) {
                    for (const key of Object.keys(entry.markers)) {
                        if (entry.markers[key] && maps[key]) maps[key].removeLayer(entry.markers[key]);
                    }
                    return false;
                }
                return true;
            });
            persistLabels();
            updateLabelsUI();
            updateOverlay();
            console.log(`‚úì Deleted label group: ${name} (${ids.size} markers)`);
        }

        // Toggle all overlays
        function toggleAllOverlays() {
            const allVisible = savedLabels.every(l => l.visible);
            savedLabels.forEach(l => l.visible = !allVisible);
            updateOverlay();
            updateLabelsUI();
        }

        // Export saved labels as JSON file (metadata only - source points + attributes)
        function exportSavedLabels() {
            if (savedLabels.length === 0) {
                alert('No labels to export.');
                return;
            }
            const data = {
                viewport: currentViewportName,
                year: currentEmbeddingYear,
                labels: savedLabels.map(l => {
                    const {pixels, visible, ...meta} = l;
                    return meta;
                })
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentViewportName}_labels.json`;
            a.click();
            URL.revokeObjectURL(url);
            labelsExportedSinceChange = true;
            updateLabelsUI();
        }

        // Export saved labels as GeoJSON FeatureCollection
        // Uses same zoom-18 Mercator projection as the JPG export so polygons
        // align pixel-perfectly with the exported map image.
        function exportSavedLabelsGeoJSON() {
            if (savedLabels.length === 0) {
                alert('No labels to export.');
                return;
            }
            if (!maps.rgb) {
                alert('Map not ready.');
                return;
            }
            const map = maps.rgb;
            const MAX_ZOOM = 18;
            const features = [];
            for (const label of savedLabels) {
                if (!label.pixels || label.pixels.length === 0) continue;
                for (const pixel of label.pixels) {
                    const pb = calculatePixelBounds(pixel.lat, pixel.lon);
                    // Project to zoom-18 pixel coords (same as JPG export)
                    const swPx = map.project(L.latLng(pb[0][0], pb[0][1]), MAX_ZOOM);
                    const nePx = map.project(L.latLng(pb[1][0], pb[1][1]), MAX_ZOOM);
                    // Match JPG export +1 pixel coverage
                    const x0 = swPx.x;
                    const y0 = nePx.y;            // top (north)
                    const x1 = nePx.x + 1;
                    const y1 = swPx.y + 1;         // bottom (south)
                    // Unproject back to geographic coords
                    const sw = map.unproject(L.point(x0, y1), MAX_ZOOM);
                    const ne = map.unproject(L.point(x1, y0), MAX_ZOOM);
                    features.push({
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [[
                                [sw.lng, sw.lat],
                                [ne.lng, sw.lat],
                                [ne.lng, ne.lat],
                                [sw.lng, ne.lat],
                                [sw.lng, sw.lat]
                            ]]
                        },
                        properties: {
                            label_name: label.name,
                            label_color: label.color,
                            distance: pixel.distance,
                            threshold: label.threshold
                        }
                    });
                }
            }
            const geojson = {
                type: 'FeatureCollection',
                features: features
            };
            const blob = new Blob([JSON.stringify(geojson, null, 2)], {type: 'application/geo+json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentViewportName}_labels.geojson`;
            a.click();
            URL.revokeObjectURL(url);
            labelsExportedSinceChange = true;
            updateLabelsUI();
        }

        // Import saved labels from JSON file
        async function importSavedLabels(file) {
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const raw = JSON.parse(e.target.result);
                    // Support both new format {viewport, labels: [...]} and old format [...]
                    const imported = Array.isArray(raw) ? raw : (raw.labels || []);
                    if (!Array.isArray(imported)) {
                        alert('Invalid label file.');
                        return;
                    }
                    const existingIds = new Set(savedLabels.map(l => l.id));
                    let added = 0;
                    for (const label of imported) {
                        if (!label.id || !label.name || !label.source_pixel) continue;
                        if (existingIds.has(label.id)) continue;
                        label.visible = true;
                        label.pixels = [];
                        savedLabels.push(label);
                        added++;
                    }
                    persistLabels();
                    labelsExportedSinceChange = true;
                    updateLabelsUI();
                    console.log(`‚úì Imported ${added} labels (${imported.length - added} skipped as duplicates)`);
                    if (added > 0) {
                        await recomputeLabelPixels();
                    }
                } catch (err) {
                    alert('Failed to parse label file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        // PersistentLabelOverlay class - renders all labels as colored pixels on RGB map
        // Uses same geographic-pixel rendering as DirectCanvasLayer for crisp results.
        const PersistentLabelOverlay = L.Layer.extend({
            initialize: function(labelsArray, options) {
                L.setOptions(this, options);
                this.labels = labelsArray;
            },

            onAdd: function(map) {
                this._map = map;

                // Use a custom Leaflet pane so the canvas sits inside the map pane's
                // stacking context ‚Äî between overlayPane (400) and markerPane (600).
                // This lets triangle markers render above the label overlay.
                if (!map.getPane('labelOverlayPane')) {
                    map.createPane('labelOverlayPane');
                    map.getPane('labelOverlayPane').style.zIndex = '550';
                    map.getPane('labelOverlayPane').style.pointerEvents = 'none';
                }

                this._canvas = document.createElement('canvas');
                this._canvas.style.position = 'absolute';
                this._canvas.style.pointerEvents = 'none';

                map.getPane('labelOverlayPane').appendChild(this._canvas);
                this._ctx = this._canvas.getContext('2d');
                this._ctx.imageSmoothingEnabled = false;
                this._updateCanvasSize();

                map.on('move zoom resize', this._redraw, this);
                this._redraw();
            },

            onRemove: function(map) {
                map.off('move zoom resize', this._redraw, this);
                if (this._canvas) this._canvas.remove();
            },

            _updateCanvasSize: function() {
                const size = this._map.getSize();
                this._canvas.width = size.x;
                this._canvas.height = size.y;
                this._canvas.style.width = size.x + 'px';
                this._canvas.style.height = size.y + 'px';
                this._ctx.imageSmoothingEnabled = false;
            },

            _redraw: function() {
                if (!this._ctx || !this._canvas || !this._map) return;

                const ctx = this._ctx;
                const map = this._map;
                const size = map.getSize();

                this._updateCanvasSize();

                // Position canvas so its (0,0) aligns with the container's (0,0)
                const topLeft = map.containerPointToLayerPoint(L.point(0, 0));
                this._canvas.style.transform = `translate(${topLeft.x}px, ${topLeft.y}px)`;

                ctx.clearRect(0, 0, size.x, size.y);

                const OVERLAP = 1.0;

                this.labels.forEach(label => {
                    if (!label.visible || !label.pixels) return;

                    // Parse color once, apply alpha
                    const c = label.color;
                    const r = parseInt(c.substr(1,2), 16);
                    const g = parseInt(c.substr(3,2), 16);
                    const b = parseInt(c.substr(5,2), 16);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;

                    for (const pixel of label.pixels) {
                        const pb = calculatePixelBounds(pixel.lat, pixel.lon);
                        const sw = map.latLngToContainerPoint(pb[0]);
                        const ne = map.latLngToContainerPoint(pb[1]);

                        if (ne.x < 0 || sw.x > size.x || sw.y < 0 || ne.y > size.y) continue;

                        const x = sw.x - OVERLAP;
                        const y = ne.y - OVERLAP;
                        const w = ne.x - sw.x + 2 * OVERLAP;
                        const h = sw.y - ne.y + 2 * OVERLAP;

                        if (w > 0.1 && h > 0.1) {
                            ctx.fillRect(x, y, w, h);
                        }
                    }
                });
            },

            updateLabels: function(newLabels) {
                this.labels = newLabels;
                this._redraw();
            }
        });

        // Global variable to hold the overlay layer
        let labelOverlay = null;

        // Update the overlay visualization
        function updateOverlay() {
            if (!maps.rgb) return;

            const visibleLabels = savedLabels.filter(l => l.visible);

            if (visibleLabels.length > 0) {
                // If overlay exists, update it in place (avoids remove/re-add timing issues)
                if (labelOverlay && maps.rgb.hasLayer(labelOverlay)) {
                    labelOverlay.updateLabels(savedLabels);
                } else {
                    // Create new overlay if it doesn't exist yet
                    labelOverlay = new PersistentLabelOverlay(savedLabels);
                    labelOverlay.addTo(maps.rgb);
                }
            } else {
                // No visible labels - remove overlay if it exists
                if (labelOverlay && maps.rgb.hasLayer(labelOverlay)) {
                    maps.rgb.removeLayer(labelOverlay);
                    labelOverlay = null;
                }
            }

            // Update UMAP colors to match labels
            updateUMAPColorsFromLabels();
        }

        // Export map as high-resolution JPG with labels and legend.
        // Fetches satellite tiles at max zoom (18) for the current view,
        // composites them with label overlays and a colour legend.
        async function exportMapAsJPG() {
            if (!maps.rgb) return;

            const btn = document.getElementById('export-dropdown-btn');
            btn.disabled = true;
            const MAX_ZOOM = 18;
            const TILE_SZ = 256;

            try {
                const map = maps.rgb;
                const bounds = map.getBounds();

                // Convert visible bounds to pixel coordinates at max zoom
                const nwPoint = map.project(bounds.getNorthWest(), MAX_ZOOM);
                const sePoint = map.project(bounds.getSouthEast(), MAX_ZOOM);

                // Tile range at max zoom
                const tileMinX = Math.floor(nwPoint.x / TILE_SZ);
                const tileMinY = Math.floor(nwPoint.y / TILE_SZ);
                const tileMaxX = Math.floor(sePoint.x / TILE_SZ);
                const tileMaxY = Math.floor(sePoint.y / TILE_SZ);

                const tilesX = tileMaxX - tileMinX + 1;
                const tilesY = tileMaxY - tileMinY + 1;
                const totalTiles = tilesX * tilesY;

                // Canvas sized to cover these tiles exactly
                const canvasW = tilesX * TILE_SZ;
                const canvasH = tilesY * TILE_SZ;

                // Offset: how many pixels into the first tile the view starts
                const offsetX = nwPoint.x - tileMinX * TILE_SZ;
                const offsetY = nwPoint.y - tileMinY * TILE_SZ;

                // The actual visible area in pixels at max zoom
                const viewW = sePoint.x - nwPoint.x;
                const viewH = sePoint.y - nwPoint.y;

                btn.textContent = `Fetching 0/${totalTiles} tiles...`;
                await new Promise(r => setTimeout(r, 50));

                const canvas = document.createElement('canvas');
                canvas.width = canvasW;
                canvas.height = canvasH;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                // Step 1: Fetch and draw all satellite tiles at max zoom
                let loaded = 0;
                const BATCH = 24; // concurrent fetches
                const tileJobs = [];
                for (let ty = tileMinY; ty <= tileMaxY; ty++) {
                    for (let tx = tileMinX; tx <= tileMaxX; tx++) {
                        tileJobs.push({tx, ty});
                    }
                }

                for (let i = 0; i < tileJobs.length; i += BATCH) {
                    const batch = tileJobs.slice(i, i + BATCH);
                    await Promise.all(batch.map(({tx, ty}) => new Promise(resolve => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => {
                            const dx = (tx - tileMinX) * TILE_SZ;
                            const dy = (ty - tileMinY) * TILE_SZ;
                            ctx.drawImage(img, dx, dy, TILE_SZ, TILE_SZ);
                            loaded++;
                            btn.textContent = `Fetching ${loaded}/${totalTiles} tiles...`;
                            resolve();
                        };
                        img.onerror = () => { loaded++; resolve(); };
                        img.src = satelliteSources[currentSatelliteSource].exportUrl(MAX_ZOOM, ty, tx);
                    })));
                }

                btn.textContent = 'Rendering labels...';
                await new Promise(r => setTimeout(r, 50));

                // Step 2: Draw label pixels at max-zoom pixel coordinates
                const visibleLabels = savedLabels.filter(l => l.visible && l.pixels && l.pixels.length > 0);
                for (const label of visibleLabels) {
                    const c = label.color;
                    const cr = parseInt(c.substr(1,2), 16);
                    const cg = parseInt(c.substr(3,2), 16);
                    const cb = parseInt(c.substr(5,2), 16);
                    ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, 0.7)`;

                    for (const pixel of label.pixels) {
                        const pb = calculatePixelBounds(pixel.lat, pixel.lon);
                        // Project pixel bounds to max-zoom pixel coords
                        const swPx = map.project(L.latLng(pb[0][0], pb[0][1]), MAX_ZOOM);
                        const nePx = map.project(L.latLng(pb[1][0], pb[1][1]), MAX_ZOOM);
                        // Convert to canvas coords (relative to tile grid origin)
                        const x = swPx.x - tileMinX * TILE_SZ;
                        const y = nePx.y - tileMinY * TILE_SZ;
                        const w = nePx.x - swPx.x + 1;
                        const h = swPx.y - nePx.y + 1;
                        if (x + w < 0 || x > canvasW || y + h < 0 || y > canvasH) continue;
                        if (w > 0.1 && h > 0.1) ctx.fillRect(x, y, w, h);
                    }
                }

                // Step 3: Crop to visible area only
                const outCanvas = document.createElement('canvas');
                outCanvas.width = Math.round(viewW);
                outCanvas.height = Math.round(viewH);
                const outCtx = outCanvas.getContext('2d');
                outCtx.imageSmoothingEnabled = false;
                outCtx.drawImage(canvas, -offsetX, -offsetY);

                // Step 4: Draw legend (scaled for high-res output)
                if (visibleLabels.length > 0) {
                    const s = Math.max(1, Math.round(outCanvas.width / 2400)); // scale factor for legend (25% of original)
                    const pad = 12 * s;
                    const rowH = 28 * s;
                    const swatchSz = 16 * s;
                    const fontSize = 15 * s;
                    const legendW = 200 * s;
                    const legendH = visibleLabels.length * rowH + pad * 2;
                    const legendX = pad;
                    const legendY = outCanvas.height - pad - legendH;

                    outCtx.fillStyle = 'rgba(255, 255, 255, 0.92)';
                    outCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    outCtx.lineWidth = s;
                    outCtx.fillRect(legendX, legendY, legendW, legendH);
                    outCtx.strokeRect(legendX, legendY, legendW, legendH);

                    outCtx.font = `bold ${fontSize}px Arial, sans-serif`;
                    outCtx.textBaseline = 'middle';
                    for (let i = 0; i < visibleLabels.length; i++) {
                        const label = visibleLabels[i];
                        const ey = legendY + pad + i * rowH + rowH / 2;

                        outCtx.fillStyle = label.color;
                        outCtx.fillRect(legendX + pad, ey - swatchSz/2, swatchSz, swatchSz);
                        outCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                        outCtx.lineWidth = s * 0.5;
                        outCtx.strokeRect(legendX + pad, ey - swatchSz/2, swatchSz, swatchSz);

                        outCtx.fillStyle = '#333';
                        outCtx.fillText(label.name, legendX + pad + swatchSz + 10 * s, ey);
                    }
                }

                // Step 5: Download as JPG
                btn.textContent = 'Saving...';
                outCanvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${currentViewportName}_labels_z${MAX_ZOOM}.jpg`;
                    a.click();
                    URL.revokeObjectURL(url);
                    btn.textContent = 'Export \u25BE';
                    btn.disabled = false;
                }, 'image/jpeg', 0.95);

            } catch (e) {
                console.error('[EXPORT] Error exporting map:', e);
                alert('Error exporting map. Check console for details.');
                btn.textContent = 'Export \u25BE';
                btn.disabled = false;
            }
        }

        // Attach event listeners to sidebar buttons and modal
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('save-label-btn').addEventListener('click', saveCurrentSearchAsLabel);
            document.getElementById('toggle-all-overlays').addEventListener('click', toggleAllOverlays);
            // Export dropdown toggle
            document.getElementById('export-dropdown-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                const menu = document.getElementById('export-dropdown-menu');
                const isHidden = getComputedStyle(menu).display === 'none';
                menu.style.display = isHidden ? 'block' : 'none';
            });
            document.addEventListener('click', () => {
                document.getElementById('export-dropdown-menu').style.display = 'none';
            });
            document.getElementById('export-dropdown-menu').addEventListener('click', (e) => {
                e.stopPropagation();
            });
            // Export dropdown items
            document.getElementById('export-labels-json-btn').addEventListener('click', () => {
                document.getElementById('export-dropdown-menu').style.display = 'none';
                exportSavedLabels();
            });
            document.getElementById('export-labels-geojson-btn').addEventListener('click', () => {
                document.getElementById('export-dropdown-menu').style.display = 'none';
                exportSavedLabelsGeoJSON();
            });
            document.getElementById('export-map-btn').addEventListener('click', () => {
                document.getElementById('export-dropdown-menu').style.display = 'none';
                exportMapAsJPG();
            });
            document.getElementById('import-labels-btn').addEventListener('click', () => {
                document.getElementById('import-labels-file').click();
            });
            document.getElementById('import-labels-file').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    importSavedLabels(e.target.files[0]);
                    e.target.value = '';  // reset so same file can be re-imported
                }
            });

            // Modal button listeners
            document.getElementById('label-save-confirm').addEventListener('click', confirmSaveLabel);
            document.getElementById('label-save-cancel').addEventListener('click', closeSaveLabelModal);

            // Color picker change - update hex display
            document.getElementById('label-color-input').addEventListener('change', function() {
                document.getElementById('color-hex-display').textContent = this.value.toUpperCase();
            });
            document.getElementById('label-color-input').addEventListener('input', function() {
                document.getElementById('color-hex-display').textContent = this.value.toUpperCase();
            });

            // Close modal when clicking overlay background
            document.getElementById('save-label-modal-overlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeSaveLabelModal();
                }
            });

            // Timeline modal close handlers
            document.getElementById('timeline-close-btn').addEventListener('click', function() {
                document.getElementById('timeline-modal-overlay').style.display = 'none';
            });
            document.getElementById('timeline-modal-overlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.style.display = 'none';
                }
            });

            // Allow Enter key to confirm
            document.getElementById('label-name-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    confirmSaveLabel();
                }
            });

            // Labels toggle button
            document.getElementById('labels-toggle-btn').addEventListener('click', function() {
                const panel = document.getElementById('labels-details-panel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            });

            // Labels close button
            document.getElementById('labels-close-btn').addEventListener('click', function() {
                document.getElementById('labels-details-panel').style.display = 'none';
            });

            // Help button toggle
            function toggleHelpPopup() {
                const popup = document.getElementById('help-popup');
                popup.style.display = popup.style.display === 'block' ? 'none' : 'block';
            }
            document.getElementById('help-btn').addEventListener('click', toggleHelpPopup);
            document.getElementById('help-close-btn').addEventListener('click', toggleHelpPopup);

            // Show help popup on first visit
            if (!localStorage.getItem('helpShown')) {
                document.getElementById('help-popup').style.display = 'block';
                localStorage.setItem('helpShown', '1');
            }

            // Status button - show/hide popup and fetch status
            document.getElementById('status-btn').addEventListener('click', async function() {
                const popup = document.getElementById('status-popup');
                const content = document.getElementById('status-content');

                if (popup.style.display === 'block') {
                    popup.style.display = 'none';
                    return;
                }

                // Show popup with loading state
                popup.style.display = 'block';
                content.innerHTML = 'Loading...';

                try {
                    const response = await fetch(`/api/viewports/${currentViewportName}/is-ready`);
                    const status = await response.json();

                    // Format the status nicely
                    const readyIcon = status.ready ? '‚úÖ' : '‚è≥';
                    const embeddingsIcon = status.has_embeddings ? '‚úÖ' : '‚ùå';
                    const pyramidsIcon = status.has_pyramids ? '‚úÖ' : '‚ùå';
                    const faissIcon = status.has_faiss ? '‚úÖ' : '‚ùå';
                    const pcaIcon = status.has_pca ? '‚úÖ' : '‚ùå';
                    const umapIcon = status.has_umap ? '‚úÖ' : '‚ùå';
                    const years = status.years_available ? status.years_available.join(', ') : 'None';

                    content.innerHTML = `
                        <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #ddd;">
                            <strong>Viewport:</strong> ${currentViewportName}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Status:</strong> ${readyIcon} ${status.message}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Embeddings:</strong> ${embeddingsIcon}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Pyramids:</strong> ${pyramidsIcon}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>FAISS Index:</strong> ${faissIcon}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>PCA (Panel 4):</strong> ${pcaIcon}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>UMAP:</strong> ${umapIcon}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Years Available:</strong> ${years}
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 10px; color: #666;">
                            Last checked: ${new Date().toLocaleTimeString()}
                        </div>
                    `;
                } catch (error) {
                    content.innerHTML = `<div style="color: #d32f2f;">Error fetching status: ${error.message}</div>`;
                }
            });

            // Status close button
            document.getElementById('status-close-btn').addEventListener('click', function() {
                document.getElementById('status-popup').style.display = 'none';
            });
        });

        // ===== END PERSISTENT LABEL SYSTEM =====

        // Expose functions to window for Three.js module access
        window.handleUnifiedClick = handleUnifiedClick;
        window.handleSimilaritySearch = handleSimilaritySearch;
        window.clearCrossPanelMarkers = clearCrossPanelMarkers;
        window.setCrossPanelMarker = setCrossPanelMarker;
    </script>

    <!-- ===== Pixelated Canvas Tile Layer ===== -->
    <script>
    // Custom tile layer that uses canvas with imageSmoothingEnabled = false
    // This guarantees crisp nearest-neighbor scaling regardless of CSS
    L.PixelatedTileLayer = L.GridLayer.extend({
        options: {
            tileSize: 256,
            crossOrigin: 'anonymous'
        },

        initialize: function(urlTemplate, options) {
            this._url = urlTemplate;
            L.setOptions(this, options);
        },

        createTile: function(coords, done) {
            const tile = document.createElement('canvas');
            const tileSize = this.getTileSize();
            tile.width = tileSize.x;
            tile.height = tileSize.y;

            const ctx = tile.getContext('2d');
            // CRITICAL: Disable image smoothing for crisp pixels
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;

            const img = new Image();
            img.crossOrigin = this.options.crossOrigin;

            img.onload = () => {
                // Re-apply after image load (some browsers reset it)
                ctx.imageSmoothingEnabled = false;
                ctx.webkitImageSmoothingEnabled = false;
                ctx.mozImageSmoothingEnabled = false;
                ctx.msImageSmoothingEnabled = false;

                // Draw image scaled to tile size - canvas will use nearest-neighbor
                ctx.drawImage(img, 0, 0, tileSize.x, tileSize.y);
                done(null, tile);
            };

            img.onerror = () => {
                done(new Error('Tile load error'), tile);
            };

            // Build URL from template
            const url = this._url
                .replace('{z}', coords.z)
                .replace('{x}', coords.x)
                .replace('{y}', coords.y);
            img.src = url;

            return tile;
        }
    });

    L.pixelatedTileLayer = function(urlTemplate, options) {
        return new L.PixelatedTileLayer(urlTemplate, options);
    };
    </script>

    <!-- ===== 3D UMAP Scene (Three.js) ‚Äî Panel 4 only ===== -->
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    class UMAPScene {
        /**
         * @param {string} containerId  ‚Äì id of the div to render into
         * @param {Array<{x,y,z,lat,lon}>} points ‚Äì UMAP coordinates from the API
         */
        constructor(containerId, points) {
            this.container = document.getElementById(containerId);
            this.points = points;           // keep reference for hit-testing
            this.disposed = false;

            // ‚îÄ‚îÄ geometry & material ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const n = points.length;
            this.geometry = new THREE.BufferGeometry();

            const positions = new Float32Array(n * 3);
            this.colors     = new Float32Array(n * 3);   // default grey

            // Compute data-space bounds for normalising into [-1, 1]
            let xMin = Infinity, xMax = -Infinity,
                yMin = Infinity, yMax = -Infinity,
                zMin = Infinity, zMax = -Infinity;

            for (let i = 0; i < n; i++) {
                const p  = points[i];
                const pz = p.z !== undefined ? p.z : 0;
                if (p.x  < xMin) xMin = p.x;   if (p.x  > xMax) xMax = p.x;
                if (p.y  < yMin) yMin = p.y;   if (p.y  > yMax) yMax = p.y;
                if (pz   < zMin) zMin = pz;    if (pz   > zMax) zMax = pz;
            }

            // Centre & scale so the cloud fits in a unit cube centred at origin
            const range = Math.max(xMax - xMin, yMax - yMin, zMax - zMin, 1e-6);
            this.dataRange = range;
            this.dataMid   = [(xMin + xMax) / 2, (yMin + yMax) / 2, (zMin + zMax) / 2];

            for (let i = 0; i < n; i++) {
                const p  = points[i];
                const pz = p.z !== undefined ? p.z : 0;
                positions[i * 3]     = (p.x  - this.dataMid[0]) / range;
                positions[i * 3 + 1] = (p.y  - this.dataMid[1]) / range;
                positions[i * 3 + 2] = (pz   - this.dataMid[2]) / range;

                // Default grey
                this.colors[i * 3]     = 0.53;   // #888
                this.colors[i * 3 + 1] = 0.53;
                this.colors[i * 3 + 2] = 0.53;
            }

            this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            this.geometry.setAttribute('color',    new THREE.BufferAttribute(this.colors, 3));

            this.material = new THREE.PointsMaterial({
                size: 0.008,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                depthWrite: false
            });

            this.pointsMesh = new THREE.Points(this.geometry, this.material);

            // ‚îÄ‚îÄ scene / camera / renderer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x1a1a2e);
            this.scene.add(this.pointsMesh);

            // Subtle ambient light (not strictly needed for PointsMaterial, but future-proof)
            this.scene.add(new THREE.AmbientLight(0xffffff, 1.0));

            const w = this.container.clientWidth  || 400;
            const h = this.container.clientHeight || 300;

            this.camera = new THREE.PerspectiveCamera(50, w / h, 0.01, 100);

            // Fit camera distance so point cloud fills the panel
            const xExtent = (xMax - xMin) / range;
            const yExtent = (yMax - yMin) / range;
            const aspect  = w / h;
            const vFovRad = 50 * Math.PI / 180;
            const hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * aspect);
            const padding = 1.15;  // 15% margin
            const distForY = (yExtent / 2 * padding) / Math.tan(vFovRad / 2);
            const distForX = (xExtent / 2 * padding) / Math.tan(hFovRad / 2);
            this.camera.position.set(0, 0, Math.max(distForY, distForX, 0.5));

            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setSize(w, h);
            this.container.innerHTML = '';          // clear any "Computing‚Ä¶" message
            this.container.appendChild(this.renderer.domElement);

            // ‚îÄ‚îÄ orbit controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enablePan    = true;
            this.controls.enableZoom   = true;
            this.controls.enableRotate = true;
            this.controls.minDistance   = 0.3;
            this.controls.maxDistance   = 8.0;

            // Swap mouse buttons: left-drag = pan, right-drag = rotate
            this.controls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };

            // ‚îÄ‚îÄ idle auto-rotation (when mouse is outside panel) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            this._idleActive = true;
            this._idleAzimuthSpeed = 0.008;   // radians per frame
            this._idlePolarSpeed  = 0.003;
            this._pickNewRotation();

            this._onMouseEnterBound = () => { this._idleActive = false; };
            this._onMouseLeavePanelBound = () => { this._idleActive = true; };
            this.container.addEventListener('mouseenter', this._onMouseEnterBound);
            this.container.addEventListener('mouseleave', this._onMouseLeavePanelBound);

            this._rotationTimer = setInterval(() => this._pickNewRotation(), 3000 + Math.random() * 3000);

            // ‚îÄ‚îÄ highlight sphere (gold, placed on click / highlightUMAPPoint) ‚îÄ‚îÄ
            const sphereGeo = new THREE.SphereGeometry(0.035, 16, 16);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            this.highlightSphere = new THREE.Mesh(sphereGeo, sphereMat);
            this.highlightSphere.visible = false;
            this.scene.add(this.highlightSphere);

            // ‚îÄ‚îÄ raycaster for click detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            this.raycaster = new THREE.Raycaster();
            this.raycaster.params.Points.threshold = 0.015;
            this._mouse = new THREE.Vector2();

            this._onClickBound    = this._onClick.bind(this);
            this._onDblClickBound = this._onDblClick.bind(this);
            this._onResizeBound   = this._onResize.bind(this);
            this._onMouseDownBound = () => { this.renderer.domElement.style.cursor = 'grabbing'; };
            this._onMouseUpBound   = () => { this.renderer.domElement.style.cursor = 'crosshair'; };

            this.renderer.domElement.addEventListener('click', this._onClickBound);
            this.renderer.domElement.addEventListener('dblclick', this._onDblClickBound);
            this.renderer.domElement.addEventListener('mousedown', this._onMouseDownBound);
            this.renderer.domElement.addEventListener('mouseup', this._onMouseUpBound);
            this.renderer.domElement.addEventListener('mouseleave', this._onMouseUpBound);
            window.addEventListener('resize', this._onResizeBound);

            // ‚îÄ‚îÄ animation loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            this._animId = null;
            this._animate();

            console.log(`[UMAPScene] Initialised: ${n} points`);
        }

        // ‚îÄ‚îÄ public API called by the main script ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        /** Move gold highlight sphere to the given point (or hide if null). */
        setHighlight(point) {
            if (!point) {
                this.highlightSphere.visible = false;
                return;
            }
            const range = this.dataRange;
            const mid   = this.dataMid;
            const pz    = point.z !== undefined ? point.z : 0;
            this.highlightSphere.position.set(
                (point.x - mid[0]) / range,
                (point.y - mid[1]) / range,
                (pz      - mid[2]) / range
            );
            this.highlightSphere.visible = true;
        }

        /**
         * Recolour points according to saved labels.
         * Each label has .pixels (array of {lat,lon}) and .color (CSS colour string).
         * Unlabelled points stay grey.
         */
        updateLabelColors(savedLabels) {
            // Build a lat/lon ‚Üí colour map (keyed to 6 dp for speed)
            const colourMap = new Map();
            for (const label of savedLabels) {
                if (!label.visible) continue;
                const rgb = this._cssColorToRGB(label.color);
                if (!rgb) continue;
                for (const px of label.pixels) {
                    const key = px.lat.toFixed(6) + ',' + px.lon.toFixed(6);
                    colourMap.set(key, rgb);
                }
            }

            const c = this.colors;
            const n = this.points.length;
            for (let i = 0; i < n; i++) {
                const key = this.points[i].lat.toFixed(6) + ',' + this.points[i].lon.toFixed(6);
                const rgb = colourMap.get(key);
                if (rgb) {
                    c[i * 3]     = rgb[0];
                    c[i * 3 + 1] = rgb[1];
                    c[i * 3 + 2] = rgb[2];
                } else {
                    c[i * 3]     = 0.53;
                    c[i * 3 + 1] = 0.53;
                    c[i * 3 + 2] = 0.53;
                }
            }

            this.geometry.attributes.color.needsUpdate = true;
        }

        /**
         * Highlight points matching similarity search results.
         * Matches are colored yellow (same as Panel 2), others stay gray.
         * @param {Array<{lat, lon, distance}>} matches - Similarity search results
         */
        highlightSimilarPoints(matches) {
            // Build a lat/lon set of matching points (keyed to 6 dp for speed)
            const matchSet = new Set();
            for (const m of matches) {
                const key = m.lat.toFixed(6) + ',' + m.lon.toFixed(6);
                matchSet.add(key);
            }

            // Yellow color for matches (same as Panel 2: #FFFF00)
            const highlightRGB = [1.0, 1.0, 0.0];  // Yellow
            const grayRGB = [0.53, 0.53, 0.53];    // Gray for non-matches

            const c = this.colors;
            const n = this.points.length;
            for (let i = 0; i < n; i++) {
                const key = this.points[i].lat.toFixed(6) + ',' + this.points[i].lon.toFixed(6);
                if (matchSet.has(key)) {
                    c[i * 3]     = highlightRGB[0];
                    c[i * 3 + 1] = highlightRGB[1];
                    c[i * 3 + 2] = highlightRGB[2];
                } else {
                    c[i * 3]     = grayRGB[0];
                    c[i * 3 + 1] = grayRGB[1];
                    c[i * 3 + 2] = grayRGB[2];
                }
            }

            this.geometry.attributes.color.needsUpdate = true;
            console.log(`[UMAPScene] Highlighted ${matchSet.size} similar points`);
        }

        /**
         * Clear similarity highlighting and restore to gray.
         */
        clearSimilarityHighlight() {
            const c = this.colors;
            const n = this.points.length;
            for (let i = 0; i < n; i++) {
                c[i * 3]     = 0.53;
                c[i * 3 + 1] = 0.53;
                c[i * 3 + 2] = 0.53;
            }
            this.geometry.attributes.color.needsUpdate = true;
        }

        /** Release GPU & DOM resources. */
        dispose() {
            this.disposed = true;
            if (this._animId !== null) cancelAnimationFrame(this._animId);
            if (this._rotationTimer) clearInterval(this._rotationTimer);
            this.container.removeEventListener('mouseenter', this._onMouseEnterBound);
            this.container.removeEventListener('mouseleave', this._onMouseLeavePanelBound);
            this.renderer.domElement.removeEventListener('click', this._onClickBound);
            this.renderer.domElement.removeEventListener('dblclick', this._onDblClickBound);
            this.renderer.domElement.removeEventListener('mousedown', this._onMouseDownBound);
            this.renderer.domElement.removeEventListener('mouseup', this._onMouseUpBound);
            this.renderer.domElement.removeEventListener('mouseleave', this._onMouseUpBound);
            window.removeEventListener('resize', this._onResizeBound);
            this.geometry.dispose();
            this.material.dispose();
            this.renderer.dispose();
            if (this.renderer.domElement.parentNode) {
                this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
            }
            console.log('[UMAPScene] Disposed');
        }

        // ‚îÄ‚îÄ internal helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        _pickNewRotation() {
            // Random azimuth speed (horizontal), random direction
            this._idleAzimuthSpeed = (0.004 + Math.random() * 0.008) * (Math.random() < 0.5 ? 1 : -1);
            // Random polar speed (vertical), random direction
            this._idlePolarSpeed  = (0.001 + Math.random() * 0.004) * (Math.random() < 0.5 ? 1 : -1);
        }

        _animate() {
            if (this.disposed) return;
            this._animId = requestAnimationFrame(() => this._animate());
            if (this._idleActive) {
                // Spherical coordinates around the target
                const offset = this.camera.position.clone().sub(this.controls.target);
                const spherical = new THREE.Spherical().setFromVector3(offset);
                spherical.theta += this._idleAzimuthSpeed;
                // Clamp polar angle to avoid flipping (keep between 15¬∞ and 165¬∞)
                spherical.phi = Math.max(0.26, Math.min(2.88, spherical.phi + this._idlePolarSpeed));
                offset.setFromSpherical(spherical);
                this.camera.position.copy(this.controls.target).add(offset);
                this.camera.lookAt(this.controls.target);
            }
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }

        _onClick(e) {
            // Raycast to find clicked point
            const rect = this.renderer.domElement.getBoundingClientRect();
            this._mouse.x =  ((e.clientX - rect.left)  / rect.width)  * 2 - 1;
            this._mouse.y = -((e.clientY - rect.top)   / rect.height) * 2 + 1;

            this.raycaster.setFromCamera(this._mouse, this.camera);
            const intersects = this.raycaster.intersectObject(this.pointsMesh);

            if (intersects.length > 0) {
                const idx = intersects[0].index;
                const hitPoint = this.points[idx];

                // Move highlight sphere
                this.setHighlight(hitPoint);

                // Use unified click handler to place markers on all panels
                if (typeof window.handleUnifiedClick === 'function') {
                    window.handleUnifiedClick(hitPoint.lat, hitPoint.lon);
                }
                console.log(`[UMAPScene] Click ‚Üí lat=${hitPoint.lat.toFixed(6)} lon=${hitPoint.lon.toFixed(6)}`);
            }
        }

        _onDblClick(e) {
            // Raycast to find double-clicked point
            const rect = this.renderer.domElement.getBoundingClientRect();
            this._mouse.x =  ((e.clientX - rect.left)  / rect.width)  * 2 - 1;
            this._mouse.y = -((e.clientY - rect.top)   / rect.height) * 2 + 1;

            this.raycaster.setFromCamera(this._mouse, this.camera);
            const intersects = this.raycaster.intersectObject(this.pointsMesh);

            if (intersects.length > 0) {
                const idx = intersects[0].index;
                const hitPoint = this.points[idx];

                // Use similarity search handler
                if (typeof window.handleSimilaritySearch === 'function') {
                    window.handleSimilaritySearch(hitPoint.lat, hitPoint.lon);
                }
                console.log(`[UMAPScene] DblClick ‚Üí similarity search at lat=${hitPoint.lat.toFixed(6)} lon=${hitPoint.lon.toFixed(6)}`);
            }
        }

        /** Public method to trigger resize (call after layout changes) */
        resize() {
            this._onResize();
        }

        _onResize() {
            if (this.disposed) return;
            const w = this.container.clientWidth  || 400;
            const h = this.container.clientHeight || 300;
            this.camera.aspect = w / h;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(w, h);
        }

        /** Parse a CSS colour string like "#a1b2c3" or "rgb(161,178,195)" ‚Üí [r,g,b] in 0-1. */
        _cssColorToRGB(css) {
            if (!css) return null;

            // Hex
            const hexMatch = css.match(/^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/);
            if (hexMatch) {
                return [
                    parseInt(hexMatch[1], 16) / 255,
                    parseInt(hexMatch[2], 16) / 255,
                    parseInt(hexMatch[3], 16) / 255
                ];
            }

            // rgb(r,g,b)
            const rgbMatch = css.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
            if (rgbMatch) {
                return [
                    parseInt(rgbMatch[1]) / 255,
                    parseInt(rgbMatch[2]) / 255,
                    parseInt(rgbMatch[3]) / 255
                ];
            }

            // Short hex #rgb
            const shortHex = css.match(/^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/);
            if (shortHex) {
                return [
                    parseInt(shortHex[1] + shortHex[1], 16) / 255,
                    parseInt(shortHex[2] + shortHex[2], 16) / 255,
                    parseInt(shortHex[3] + shortHex[3], 16) / 255
                ];
            }

            return null;
        }
    }

    // ‚îÄ‚îÄ expose to the main (non-module) script ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    window.UMAPScene = UMAPScene;

    // Also expose the cross-panel helpers so the click handler above can call them.
    // The main script defines them inside a closure; re-export them on window if not already there.
    // (They are already on window via the main script's global scope in non-strict mode ‚Äî this is a safety net.)
    </script>

    <!-- Change Password Modal -->
    <div id="changePasswordModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; align-items:center; justify-content:center;">
        <div style="background:white; border-radius:8px; padding:24px; width:360px; box-shadow:0 8px 32px rgba(0,0,0,0.3);">
            <h3 style="margin:0 0 16px 0; font-size:16px; color:#333;">Change Password</h3>
            <input type="password" id="cpCurrent" placeholder="Current password" style="width:100%; padding:8px 10px; border:1px solid #ddd; border-radius:4px; font-size:13px; margin-bottom:10px;" />
            <input type="password" id="cpNew" placeholder="New password" style="width:100%; padding:8px 10px; border:1px solid #ddd; border-radius:4px; font-size:13px; margin-bottom:10px;" />
            <input type="password" id="cpConfirm" placeholder="Confirm new password" style="width:100%; padding:8px 10px; border:1px solid #ddd; border-radius:4px; font-size:13px; margin-bottom:10px;" />
            <div id="cpMsg" style="font-size:12px; margin-top:8px; min-height:18px;"></div>
            <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:6px;">
                <button onclick="hideChangePassword()" style="padding:6px 16px; border:none; border-radius:4px; cursor:pointer; font-size:13px; background:#e9ecef; color:#333;">Cancel</button>
                <button onclick="submitChangePassword()" style="padding:6px 16px; border:none; border-radius:4px; cursor:pointer; font-size:13px; background:#667eea; color:white; font-weight:600;">Change</button>
            </div>
        </div>
    </div>

    <script>
        function showChangePassword() {
            document.getElementById('cpCurrent').value = '';
            document.getElementById('cpNew').value = '';
            document.getElementById('cpConfirm').value = '';
            var msg = document.getElementById('cpMsg');
            msg.textContent = '';
            msg.style.color = '';
            var modal = document.getElementById('changePasswordModal');
            modal.style.display = 'flex';
        }

        function hideChangePassword() {
            document.getElementById('changePasswordModal').style.display = 'none';
        }

        function submitChangePassword() {
            var current = document.getElementById('cpCurrent').value;
            var newPw = document.getElementById('cpNew').value;
            var confirm = document.getElementById('cpConfirm').value;
            var msg = document.getElementById('cpMsg');

            if (!current || !newPw) {
                msg.textContent = 'Please fill in all fields.';
                msg.style.color = '#dc3545';
                return;
            }
            if (newPw !== confirm) {
                msg.textContent = 'New passwords do not match.';
                msg.style.color = '#dc3545';
                return;
            }

            fetch('/api/auth/change-password', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({current_password: current, new_password: newPw})
            }).then(function(r) { return r.json(); }).then(function(data) {
                if (data.success) {
                    msg.textContent = 'Password changed successfully.';
                    msg.style.color = '#28a745';
                    setTimeout(hideChangePassword, 1500);
                } else {
                    msg.textContent = data.error || 'Failed to change password.';
                    msg.style.color = '#dc3545';
                }
            }).catch(function() {
                msg.textContent = 'Network error.';
                msg.style.color = '#dc3545';
            });
        }

        // Close modal on overlay click
        document.getElementById('changePasswordModal').addEventListener('click', function(e) {
            if (e.target === this) hideChangePassword();
        });
    </script>
</body>
</html>
