<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TEE Viewport Manager</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        /* Left Sidebar */
        .sidebar {
            width: 350px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .sidebar-header p {
            font-size: 12px;
            opacity: 0.9;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        /* Search Bar */
        .search-container {
            margin-bottom: 20px;
        }

        .search-container input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }

        .search-container input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Viewports List */
        .viewports-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .viewport-item {
            padding: 12px;
            border: 1px solid #eee;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .viewport-item:hover {
            border-color: #667eea;
            background: #f9f9ff;
        }

        .viewport-item.active {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .viewport-item-name {
            font-weight: 600;
            font-size: 13px;
            color: #333;
            margin-bottom: 4px;
        }

        .viewport-item-coords {
            font-size: 11px;
            color: #999;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .viewport-item.active .viewport-item-name {
            color: #667eea;
        }

        .viewport-item-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .viewport-item-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 10px;
            border: 1px solid #ddd;
            background: white;
            color: #666;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .viewport-item-btn:hover {
            background: #f5f5f5;
            border-color: #667eea;
            color: #667eea;
        }

        .viewport-item-btn.delete:hover {
            background: #ffebee;
            border-color: #d32f2f;
            color: #d32f2f;
        }

        /* Current Viewport Panel */
        .current-viewport {
            padding: 12px;
            background: #f9f9ff;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .current-viewport-title {
            font-size: 12px;
            font-weight: 600;
            color: #667eea;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .current-viewport-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }

        .current-viewport-bounds {
            font-size: 11px;
            color: #666;
            font-family: 'Monaco', 'Courier New', monospace;
            line-height: 1.4;
        }

        /* Create New Viewport Form */
        .create-form {
            padding: 12px;
            background: #f5f5f5;
            border-radius: 6px;
            display: none;
        }

        .create-form.open {
            display: block;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
        }

        .form-group input,
        .form-group.input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group.input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .button-group {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 1px solid #667eea;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #f9f9ff;
        }

        .btn-small {
            padding: 6px 10px;
            font-size: 11px;
        }

        .btn-toggle {
            background: white;
            color: #667eea;
            border: 1px solid #ddd;
            width: 100%;
            margin-bottom: 12px;
        }

        .btn-toggle:hover {
            background: #f9f9ff;
        }

        /* Download Section */
        .downloads-section {
            padding: 12px;
            background: #fffaed;
            border: 1px solid #ffe4b5;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .downloads-title {
            font-size: 12px;
            font-weight: 600;
            color: #b8860b;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .download-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-download {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: white;
            color: #b8860b;
            border: 1px solid #daa520;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-download:hover:not(:disabled) {
            background: #fffaed;
            border-color: #b8860b;
        }

        .btn-download:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-download.downloading {
            opacity: 0.8;
            cursor: wait;
        }

        .download-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
        }

        .download-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
        }

        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Status Messages */
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 12px;
            text-align: center;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }

        /* Info Panel on Map */
        .map-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            font-size: 12px;
            max-width: 280px;
            z-index: 400;
        }

        .map-info-label {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 4px;
        }

        .map-info-value {
            font-family: 'Monaco', 'Courier New', monospace;
            color: #333;
            font-size: 11px;
            line-height: 1.4;
        }

        .map-info-coords {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 10px;
            color: #555;
            line-height: 1.6;
        }

        .map-info-coords-label {
            font-weight: 600;
            color: #667eea;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 11px;
            margin-bottom: 4px;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>TEE Viewport Manager</h1>
            </div>

            <div class="sidebar-content">
                <!-- Search -->
                <div class="section">
                    <div class="section-title">Search Viewports</div>
                    <div class="search-container">
                        <input type="text" id="viewportSearch" placeholder="Search by name...">
                    </div>
                </div>

                <!-- Available Viewports -->
                <div class="section">
                    <div class="section-title">Available Viewports</div>
                    <div id="viewportsList" class="viewports-list">
                        <p style="color: #999; font-size: 12px;">Loading viewports...</p>
                    </div>
                </div>

                <!-- Current Viewport -->
                <div class="section">
                    <div class="current-viewport" id="currentViewport">
                        <div class="current-viewport-title">Active Viewport</div>
                        <div class="current-viewport-name" id="currentName">Loading...</div>
                        <div class="current-viewport-bounds" id="currentBounds"></div>
                    </div>
                </div>

                <!-- Processing Status -->
                <div class="section" id="processingSection" style="display: none; background: #f0f4ff; padding: 12px; border-radius: 6px; border-left: 3px solid #667eea;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="font-size: 12px; color: #667eea; font-weight: 600;">Processing Viewport</div>
                        <button id="cancelProcessingBtn" onclick="cancelProcessing()" style="padding: 4px 10px; font-size: 11px; background: #ff5252; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                    </div>
                    <div id="processingViewportName" style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 6px;"></div>
                    <div style="background: #e0e0e0; border-radius: 4px; height: 10px; overflow: hidden; margin-bottom: 6px;">
                        <div id="processingProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s ease;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span id="processingPercent" style="font-size: 12px; color: #667eea; font-weight: 600;">0%</span>
                        <span id="processingElapsed" style="font-size: 11px; color: #888;"></span>
                    </div>
                    <div id="processingStage" style="font-size: 12px; color: #333; font-weight: 500; margin-bottom: 4px;">‚è≥ Starting...</div>
                    <div id="processingMessage" style="font-size: 11px; color: #555; line-height: 1.3;"></div>
                    <div id="processingFile" style="font-size: 10px; color: #888; margin-top: 4px; font-family: monospace; word-break: break-all;"></div>
                    <div id="processingBytes" style="font-size: 10px; color: #888; margin-top: 2px;"></div>
                </div>

                <!-- Create New Viewport -->
                <div class="section">
                    <button class="btn btn-toggle" onclick="toggleCreateForm()">+ Create New Viewport</button>

                    <div class="create-form" id="createForm">
                        <!-- Geocode search -->
                        <div style="margin-bottom: 10px; position: relative;">
                            <label style="font-weight: 600; font-size: 13px; display: block; margin-bottom: 6px;">Search for a location</label>
                            <input type="text" id="geocodeSearch" placeholder="e.g. London, Paris, Tokyo..." autocomplete="off"
                                style="width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                            <div id="geocodeResults" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-top: none; border-radius: 0 0 4px 4px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 2px 6px rgba(0,0,0,0.15);">
                            </div>
                        </div>

                        <div id="mapClickInstruction" style="font-size: 12px; color: #333; margin-bottom: 12px; padding: 10px; background: #e8f4f8; border-radius: 6px; border-left: 3px solid #667eea;">
                            üìç <strong>Or click on the map</strong> to create a 5km √ó 5km viewport centered at that location
                        </div>
                        <div id="formFields" style="display: none;">
                            <div class="form-group">
                                <label>Viewport Name <span style="color: #d32f2f;">*</span></label>
                                <input type="text" id="viewportName" placeholder="e.g., bangalore_south" class="form-group input" required>
                            </div>
                            <div style="margin-top: 12px; padding: 0;">
                                <label style="font-weight: 600; margin-bottom: 8px; display: block; font-size: 14px;">Download years (2017-2025):</label>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2017" class="year-checkbox" value="2017" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2017
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2018" class="year-checkbox" value="2018" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2018
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2019" class="year-checkbox" value="2019" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2019
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2020" class="year-checkbox" value="2020" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2020
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2021" class="year-checkbox" value="2021" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2021
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2022" class="year-checkbox" value="2022" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2022
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2023" class="year-checkbox" value="2023" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2023
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2024" class="year-checkbox" value="2024" checked style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2024
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2025" class="year-checkbox" value="2025" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2025
                                    </label>
                                </div>
                                <div style="font-size: 12px; color: #666;">
                                    <button type="button" onclick="selectAllYears()" style="background: none; border: none; color: #667eea; cursor: pointer; text-decoration: underline; padding: 0; font-size: 12px;">Select All</button>
                                    <span style="margin: 0 4px;">‚Ä¢</span>
                                    <button type="button" onclick="selectNoYears()" style="background: none; border: none; color: #667eea; cursor: pointer; text-decoration: underline; padding: 0; font-size: 12px;">Select None</button>
                                </div>
                            </div>
                            <div class="button-group">
                                <button class="btn btn-primary btn-small" onclick="confirmViewportCreation()">Create</button>
                                <button class="btn btn-secondary btn-small" onclick="cancelViewportCreation()">Cancel</button>
                            </div>
                        </div>
                        <div id="closeButton" style="text-align: center; padding: 20px 10px;">
                            <button class="btn btn-secondary" onclick="toggleCreateForm()" style="width: auto;">Close</button>
                        </div>
                    </div>
                </div>

                <!-- Quick Viewer Access -->
                <div class="section" style="margin-top: auto; border-top: 1px solid #ddd; padding-top: 15px;">
                    <div id="dataStatusMessage" style="font-size: 12px; color: #666; margin-bottom: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; display: none;">
                        <div id="dataStatusText">Loading...</div>
                    </div>

                    <!-- Viewer Type Selection -->
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">Viewer Type:</label>
                        <select id="viewer-type-selector" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: white; color: #333;">
                            <option value="viewer.html">Standard Viewer</option>
                            <option value="experimental_viewer.html">Advanced Viewer</option>
                        </select>
                    </div>

                    <button class="btn-download" id="quickViewerBtn" onclick="goToViewer()" style="width: 100%; border-color: #667eea; color: #667eea; background: #f0f4ff;">
                        <span>‚ñ∂ Open Viewer</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            <div class="map-info" id="mapInfo">
                <div class="map-info-label" id="mapInfoLabel">Click on map</div>
                <div class="map-info-value" id="mapInfoValue">to select viewport center</div>
                <div class="map-info-coords" id="mapInfoCoords" style="display: none;">
                    <div class="map-info-coords-label">Bounding Box</div>
                    <div id="mapInfoCoordsContent"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <script>
        // Global state
        let map;
        let viewportBox;
        let currentViewport = null;
        let mapCenter = [20.0, 78.0]; // Default center of India (will be updated when viewport loads)
        let mapZoom = 5; // Default zoom (will be updated when viewport loads)

        // Viewport selection state
        let previewBox = null;
        let pendingViewportBounds = null;

        // Constants
        const VIEWPORT_SIZE_KM = 5;
        const KM_PER_DEGREE = 111.32; // approximate at equator

        // Convert km to degrees (approximate)
        function kmToDegrees(km, latitude) {
            const latOffset = km / KM_PER_DEGREE;
            const lngOffset = km / (KM_PER_DEGREE * Math.cos(latitude * Math.PI / 180));
            return { latOffset, lngOffset };
        }

        // Initialize map
        function initMap() {
            map = L.map('map').setView(mapCenter, mapZoom);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Add click handler for viewport creation
            map.on('click', function(e) {
                const formOpen = document.getElementById('createForm').classList.contains('open');
                console.log('[MAP CLICK] Form open:', formOpen, 'Latlng:', e.latlng);
                if (formOpen) {
                    console.log('[MAP CLICK] Creating viewport from click at:', e.latlng);
                    createViewportFromClick(e.latlng);
                } else {
                    console.log('[MAP CLICK] Form not open, ignoring click');
                }
            });

            // Show preview following mouse only until a location is locked in by clicking
            map.on('mousemove', function(e) {
                if (document.getElementById('createForm').classList.contains('open') && !pendingViewportBounds) {
                    showViewportPreview(e.latlng);
                    // Show live bounding box coordinates
                    const offsets = kmToDegrees(VIEWPORT_SIZE_KM / 2, e.latlng.lat);
                    const minLat = e.latlng.lat - offsets.latOffset;
                    const maxLat = e.latlng.lat + offsets.latOffset;
                    const minLon = e.latlng.lng - offsets.lngOffset;
                    const maxLon = e.latlng.lng + offsets.lngOffset;
                    showBoundsCoordinates(minLat, maxLat, minLon, maxLon);
                    document.getElementById('mapInfoLabel').textContent = 'Viewport Preview';
                    document.getElementById('mapInfoValue').textContent = '5km √ó 5km (click to place)';
                }
            });

            // Hide preview on mouseout only if not yet locked (locked box stays visible)
            map.getContainer().addEventListener('mouseout', function() {
                if (previewBox && !pendingViewportBounds) {
                    map.removeLayer(previewBox);
                    previewBox = null;
                    hideBoundsCoordinates();
                    document.getElementById('mapInfoLabel').textContent = 'Click on map';
                    document.getElementById('mapInfoValue').textContent = 'to select viewport center';
                }
            });
        }

        // --- Geocode search (Nominatim) ---
        let geocodeDebounceTimer = null;

        function initGeocodeSearch() {
            const input = document.getElementById('geocodeSearch');
            input.addEventListener('input', function() {
                clearTimeout(geocodeDebounceTimer);
                const query = input.value.trim();
                if (query.length < 2) {
                    hideGeocodeResults();
                    return;
                }
                geocodeDebounceTimer = setTimeout(() => fetchGeocode(query), 300);
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#geocodeSearch') && !e.target.closest('#geocodeResults')) {
                    hideGeocodeResults();
                }
            });
        }

        async function fetchGeocode(query) {
            try {
                const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5&addressdetails=1`;
                const response = await fetch(url, {
                    headers: { 'User-Agent': 'Tessera Viewport Selector' }
                });
                const results = await response.json();
                renderGeocodeResults(results);
            } catch (error) {
                console.error('[GEOCODE] Fetch failed:', error);
                hideGeocodeResults();
            }
        }

        function renderGeocodeResults(results) {
            const container = document.getElementById('geocodeResults');
            container.innerHTML = '';

            if (!results || results.length === 0) {
                container.style.display = 'none';
                return;
            }

            results.forEach(result => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;';
                div.style.whiteSpace = 'nowrap';
                div.style.overflow = 'hidden';
                div.style.textOverflow = 'ellipsis';

                // Build label: name + address context
                const name = result.name || result.display_name.split(',')[0];
                const addr = result.address || {};
                const context = [addr.city, addr.county, addr.state, addr.country].filter(Boolean).join(', ');
                div.innerHTML = `<strong>${name}</strong>${context ? ' <span style="color:#666; font-weight:normal;">' + context + '</span>' : ''}`;

                div.addEventListener('mouseenter', () => div.style.background = '#f0f7ff');
                div.addEventListener('mouseleave', () => div.style.background = 'white');

                div.addEventListener('click', () => selectGeocodeResult(result));
                container.appendChild(div);
            });

            container.style.display = 'block';
        }

        function hideGeocodeResults() {
            document.getElementById('geocodeResults').style.display = 'none';
        }

        function selectGeocodeResult(result) {
            const lat = parseFloat(result.lat);
            const lon = parseFloat(result.lon);

            // Close dropdown and clear input
            hideGeocodeResults();
            document.getElementById('geocodeSearch').value = result.display_name.split(',').slice(0, 2).join(',').trim();

            // Pan map to the selected location
            map.setView([lat, lon], 12);

            // Show the 5km preview box and trigger the same flow as a map click
            showViewportPreview({ lat, lng: lon });
            createViewportFromClick({ lat, lng: lon });

            // Pre-fill viewport name from the geocode result (createViewportFromClick clears it, so do this after)
            const placeName = (result.name || result.display_name.split(',')[0])
                .replace(/[^a-zA-Z0-9 _-]/g, '')   // strip special chars
                .trim()
                .replace(/\s+/g, '_');              // spaces to underscores
            if (placeName) {
                document.getElementById('viewportName').value = placeName;
            }
        }

        // Show preview of 5km √ó 5km viewport
        function showViewportPreview(latlng) {
            const offsets = kmToDegrees(VIEWPORT_SIZE_KM / 2, latlng.lat);

            const bounds = [
                [latlng.lat - offsets.latOffset, latlng.lng - offsets.lngOffset],
                [latlng.lat + offsets.latOffset, latlng.lng + offsets.lngOffset]
            ];

            // Remove old preview
            if (previewBox) {
                map.removeLayer(previewBox);
            }

            // Create new preview
            previewBox = L.rectangle(bounds, {
                color: '#ff6b35',
                weight: 2,
                opacity: 0.7,
                fill: true,
                fillColor: '#ff6b35',
                fillOpacity: 0.1,
                interactive: false
            }).addTo(map);

            previewBox.bringToFront();
        }

        // Show bounding box coordinates in map info panel
        function showBoundsCoordinates(minLat, maxLat, minLon, maxLon) {
            const coordsDiv = document.getElementById('mapInfoCoords');
            const contentDiv = document.getElementById('mapInfoCoordsContent');

            contentDiv.innerHTML = `
                <div>NW: ${maxLat.toFixed(6)}¬∞, ${minLon.toFixed(6)}¬∞</div>
                <div>NE: ${maxLat.toFixed(6)}¬∞, ${maxLon.toFixed(6)}¬∞</div>
                <div>SW: ${minLat.toFixed(6)}¬∞, ${minLon.toFixed(6)}¬∞</div>
                <div>SE: ${minLat.toFixed(6)}¬∞, ${maxLon.toFixed(6)}¬∞</div>
            `;
            coordsDiv.style.display = 'block';
        }

        // Hide bounding box coordinates
        function hideBoundsCoordinates() {
            document.getElementById('mapInfoCoords').style.display = 'none';
        }

        // Prepare viewport for naming (called when map is clicked)
        async function createViewportFromClick(latlng) {
            console.log('[CREATE VIEWPORT] Starting creation at:', latlng);
            const offsets = kmToDegrees(VIEWPORT_SIZE_KM / 2, latlng.lat);

            const minLat = latlng.lat - offsets.latOffset;
            const maxLat = latlng.lat + offsets.latOffset;
            const minLon = latlng.lng - offsets.lngOffset;
            const maxLon = latlng.lng + offsets.lngOffset;

            const isFirstPlacement = !pendingViewportBounds;

            // Store / update bounds for later creation
            pendingViewportBounds = {
                bounds: `${minLon.toFixed(6)},${minLat.toFixed(6)},${maxLon.toFixed(6)},${maxLat.toFixed(6)}`,
                minLat, maxLat, minLon, maxLon
            };
            console.log('[CREATE VIEWPORT] Bounds:', pendingViewportBounds.bounds);

            // Always update the visual box to the clicked position
            showViewportPreview(latlng);

            // Always show coordinates when box is placed/moved
            showBoundsCoordinates(minLat, maxLat, minLon, maxLon);

            // Show the naming form only on first placement; subsequent clicks just reposition the box
            if (isFirstPlacement) {
                document.getElementById('formFields').style.display = 'block';
                document.getElementById('closeButton').style.display = 'none';
                document.getElementById('viewportName').value = '';
                document.getElementById('viewportName').focus();

                document.getElementById('mapInfoLabel').textContent = 'Viewport Bounds';
                document.getElementById('mapInfoValue').textContent = '5km √ó 5km';
                console.log('[CREATE VIEWPORT] Form fields shown, ready for user input');
            }
        }

        // Year selection helpers
        function selectAllYears() {
            document.querySelectorAll('.year-checkbox').forEach(cb => cb.checked = true);
        }

        function selectNoYears() {
            document.querySelectorAll('.year-checkbox').forEach(cb => cb.checked = false);
        }

        function getSelectedYears() {
            const selected = [];
            document.querySelectorAll('.year-checkbox:checked').forEach(cb => {
                selected.push(parseInt(cb.value));
            });
            return selected.sort();
        }

        async function confirmViewportCreation() {
            if (!pendingViewportBounds) return;

            const name = document.getElementById('viewportName').value.trim();
            const bounds = pendingViewportBounds.bounds;
            const years = getSelectedYears();

            // Validate viewport name is provided
            if (!name) {
                alert('Please enter a viewport name');
                document.getElementById('viewportName').focus();
                return;
            }

            // Validate that at least one year is selected
            if (years.length === 0) {
                alert('Please select at least one year to download');
                return;
            }

            // Hide form
            document.getElementById('formFields').style.display = 'none';
            document.getElementById('closeButton').style.display = 'block';

            // Show loading state
            document.getElementById('mapInfoLabel').textContent = 'Creating viewport...';
            document.getElementById('mapInfoValue').textContent = `Downloading embeddings for ${years.length} year${years.length > 1 ? 's' : ''}...`;
            hideBoundsCoordinates();

            try {
                // Create the viewport via API
                const response = await fetch('/api/viewports/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bounds, name, description: `${VIEWPORT_SIZE_KM}km √ó ${VIEWPORT_SIZE_KM}km`, years })
                });

                const data = await response.json();

                if (data.success) {
                    // Remove preview box
                    if (previewBox) {
                        map.removeLayer(previewBox);
                        previewBox = null;
                    }

                    // Data is being prepared in background
                    console.log('[VIEWPORT CREATE] Viewport created:', name);
                    console.log('[VIEWPORT CREATE] Waiting for data to be ready...');

                    // Update current viewport and refresh UI to show it as active
                    currentViewport = data.viewport;
                    updateCurrentViewportDisplay();
                    loadViewports(); // Refresh list to show as active
                    drawViewportBox();

                    // Hide the create form and show processing status in left sidebar
                    document.getElementById('createForm').classList.remove('open');
                    document.getElementById('mapClickInstruction').style.display = 'none';
                    document.getElementById('processingSection').style.display = 'block';
                    document.getElementById('cancelProcessingBtn').style.display = 'inline-block';
                    document.getElementById('mapInfoLabel').textContent = '';
                    document.getElementById('mapInfoValue').textContent = '';

                    // Start progress polling for the new viewport
                    startProgressPolling(name);

                    // Wait for viewport to be ready
                    const isReady = await waitForViewportReady(name);

                    // Hide processing section
                    document.getElementById('processingSection').style.display = 'none';

                    if (isReady) {
                        console.log('[VIEWPORT CREATE] ‚úì Data is ready, navigating to viewer...');
                        // Use the user's selected viewer (respects Advanced/Standard choice)
                        const viewerType = document.getElementById('viewer-type-selector').value;
                        console.log(`[VIEWPORT CREATE] Navigating to ${viewerType}`);
                        window.location.href = viewerType;
                    } else {
                        console.log('[VIEWPORT CREATE] ‚úó Timeout waiting for data');
                        document.getElementById('processingMessage').textContent = '‚úó Processing timeout - please check back in a few minutes';
                        // Keep processing section visible to show error message
                        document.getElementById('mapClickInstruction').style.display = 'inline-block';
                    }

                    // Clear pending bounds
                    pendingViewportBounds = null;
                } else {
                    document.getElementById('processingSection').style.display = 'none';
                    document.getElementById('mapClickInstruction').style.display = 'inline-block';
                    document.getElementById('mapInfoLabel').textContent = '‚úó Error creating viewport';
                    document.getElementById('mapInfoValue').textContent = data.error || 'Unknown error';
                    hideBoundsCoordinates();

                    // Remove preview box
                    if (previewBox) {
                        map.removeLayer(previewBox);
                        previewBox = null;
                    }

                    // Close form on error
                    setTimeout(() => {
                        document.getElementById('createForm').classList.remove('open');
                        drawViewportBox();
                    }, 2000);
                }
            } catch (error) {
                document.getElementById('processingSection').style.display = 'none';
                document.getElementById('mapClickInstruction').style.display = 'inline-block';
                document.getElementById('mapInfoLabel').textContent = '‚úó Error creating viewport';
                document.getElementById('mapInfoValue').textContent = error.message;
                hideBoundsCoordinates();

                // Remove preview box
                if (previewBox) {
                    map.removeLayer(previewBox);
                    previewBox = null;
                }

                // Close form on error
                setTimeout(() => {
                    document.getElementById('createForm').classList.remove('open');
                    drawViewportBox();
                    document.getElementById('mapInfoLabel').textContent = 'Click on map';
                    document.getElementById('mapInfoValue').textContent = 'to select viewport center';
                    hideBoundsCoordinates();
                }, 2000);
            }
        }

        // Cancel viewport creation
        function cancelViewportCreation() {
            document.getElementById('formFields').style.display = 'none';
            document.getElementById('closeButton').style.display = 'block';
            document.getElementById('viewportName').value = '';
            document.getElementById('mapClickInstruction').style.display = 'inline-block';
            document.getElementById('processingSection').style.display = 'none';
            pendingViewportBounds = null;

            // Remove preview box
            if (previewBox) {
                map.removeLayer(previewBox);
                previewBox = null;
            }

            document.getElementById('mapInfoLabel').textContent = 'Click on map';
            document.getElementById('mapInfoValue').textContent = 'to select viewport center';
            hideBoundsCoordinates();
        }

        // Load current viewport
        async function loadCurrentViewport() {
            try {
                const response = await fetch('/api/viewports/current');
                const data = await response.json();

                if (data.success) {
                    currentViewport = data.viewport;
                    updateCurrentViewportDisplay();
                    drawViewportBox();

                    // Check if data exists for this viewport
                    checkViewportData();
                }
            } catch (error) {
                console.error('Error loading current viewport:', error);
            }
        }

        // Check if pyramids exist for current viewport (with timeout)
        async function checkViewportData() {
            // Run check asynchronously without blocking page load
            setTimeout(async () => {
                try {
                    // Check multiple possible locations for pyramid metadata
                    const pyramidPaths = [
                        'pyramids/2024/pyramid_metadata.json',
                        'pyramids/pyramid_metadata.json',
                        'pyramids/2024/level_0.tif'
                    ];

                    let hasData = false;

                    // Check each path with a 2-second timeout
                    for (const path of pyramidPaths) {
                        try {
                            const controller = new AbortController();
                            const timeout = setTimeout(() => controller.abort(), 2000);

                            const response = await fetch(path, {
                                method: 'HEAD',
                                signal: controller.signal
                            });

                            clearTimeout(timeout);

                            if (response.ok) {
                                hasData = true;
                                break;
                            }
                        } catch (e) {
                            // Continue to next path (timeout or network error)
                        }
                    }

                    const downloadBtn = document.getElementById('downloadBtn');
                    const viewerBtn = document.getElementById('viewerBtn');

                    if (!downloadBtn || !viewerBtn) {
                        return; // Buttons might not exist yet
                    }

                    if (hasData) {
                        console.log('‚úì Pyramid data found - showing viewer button');
                        downloadBtn.style.display = 'none';
                        viewerBtn.style.display = 'block';
                    } else {
                        console.log('‚úó No pyramid data found - showing download button');
                        downloadBtn.style.display = 'block';
                        viewerBtn.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error checking viewport data:', error);
                    // If we can't determine, show download button
                    const downloadBtn = document.getElementById('downloadBtn');
                    const viewerBtn = document.getElementById('viewerBtn');
                    if (downloadBtn && viewerBtn) {
                        downloadBtn.style.display = 'block';
                        viewerBtn.style.display = 'none';
                    }
                }
            }, 100);
        }

        // Track active progress polling interval
        let activeProgressPollInterval = null;
        let activeProgressViewport = null;

        // Check and display viewport status using unified is-ready endpoint
        async function checkAndDisplayDataStatus(viewportName) {
            try {
                const response = await fetch(`/api/viewports/${viewportName}/is-ready`);
                const status = await response.json();

                const statusEl = document.getElementById('dataStatusMessage');
                const statusText = document.getElementById('dataStatusText');

                // Use message from server (already formatted)
                if (status.ready) {
                    statusEl.style.background = '#e8f5e9';
                    statusEl.style.color = '#2e7d32';
                    // Hide processing section if viewport is ready
                    document.getElementById('processingSection').style.display = 'none';
                    // Stop any active polling
                    if (activeProgressPollInterval) {
                        clearInterval(activeProgressPollInterval);
                        activeProgressPollInterval = null;
                        activeProgressViewport = null;
                    }
                } else {
                    statusEl.style.background = '#fff3cd';
                    statusEl.style.color = '#856404';
                    // Show detailed progress section and start polling
                    document.getElementById('processingSection').style.display = 'block';
                    startProgressPolling(viewportName);
                }

                statusText.textContent = status.message;
                statusEl.style.display = 'block';

                // Disable viewer button if data not ready
                const viewerBtn = document.getElementById('quickViewerBtn');
                viewerBtn.disabled = !status.ready;
                if (!status.ready) {
                    viewerBtn.style.opacity = '0.5';
                    viewerBtn.style.cursor = 'not-allowed';
                } else {
                    viewerBtn.style.opacity = '1';
                    viewerBtn.style.cursor = 'pointer';
                }
            } catch (error) {
                console.error('Error checking data status:', error);
            }
        }

        // Cancel processing for the active viewport
        async function cancelProcessing() {
            if (!activeProgressViewport) {
                alert('No viewport is currently being processed');
                return;
            }

            if (!confirm(`Cancel processing for "${activeProgressViewport}"?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/viewports/${activeProgressViewport}/cancel-processing`, {
                    method: 'POST'
                });
                const result = await response.json();

                if (result.success) {
                    // Stop polling
                    if (activeProgressPollInterval) {
                        clearInterval(activeProgressPollInterval);
                        activeProgressPollInterval = null;
                    }

                    // Update UI
                    document.getElementById('processingStage').textContent = '‚ùå Cancelled';
                    document.getElementById('processingMessage').textContent = 'Processing was cancelled by user';
                    document.getElementById('cancelProcessingBtn').style.display = 'none';

                    // Hide processing section after a delay
                    setTimeout(() => {
                        document.getElementById('processingSection').style.display = 'none';
                        activeProgressViewport = null;
                        loadViewports(); // Refresh viewport list
                    }, 2000);
                } else {
                    alert(result.message || 'Failed to cancel processing');
                }
            } catch (error) {
                console.error('Error cancelling processing:', error);
                alert('Error cancelling processing: ' + error.message);
            }
        }

        // Start polling for detailed progress on a viewport
        function startProgressPolling(viewportName) {
            // Don't start duplicate polling for same viewport
            if (activeProgressViewport === viewportName && activeProgressPollInterval) {
                return;
            }

            // Stop any existing polling
            if (activeProgressPollInterval) {
                clearInterval(activeProgressPollInterval);
            }

            activeProgressViewport = viewportName;

            // Initialize with basic info
            updateSidebarProgress(viewportName, {
                percent: 0,
                status: 'processing',
                message: 'Checking progress...'
            });

            // Poll every 2 seconds
            activeProgressPollInterval = setInterval(async () => {
                try {
                    // Check if ready
                    const readyResponse = await fetch(`/api/viewports/${viewportName}/is-ready`);
                    const readyResult = await readyResponse.json();

                    if (readyResult.ready) {
                        // Viewport is ready - stop polling and update UI
                        updateSidebarProgress(viewportName, {
                            percent: 100,
                            status: 'complete',
                            message: 'Ready to view!'
                        });
                        clearInterval(activeProgressPollInterval);
                        activeProgressPollInterval = null;
                        activeProgressViewport = null;

                        // Update the status display
                        const statusEl = document.getElementById('dataStatusMessage');
                        const statusText = document.getElementById('dataStatusText');
                        statusEl.style.background = '#e8f5e9';
                        statusEl.style.color = '#2e7d32';
                        statusText.textContent = readyResult.message;

                        // Enable viewer button
                        const viewerBtn = document.getElementById('quickViewerBtn');
                        viewerBtn.disabled = false;
                        viewerBtn.style.opacity = '1';
                        viewerBtn.style.cursor = 'pointer';
                        return;
                    }

                    // Poll pipeline progress
                    try {
                        const progressResponse = await fetch(`/api/operations/progress/${viewportName}_pipeline`);
                        const progress = await progressResponse.json();

                        if (progress.success && progress.status !== 'not_started') {
                            updateSidebarProgress(viewportName, progress);
                        } else {
                            updateSidebarProgress(viewportName, {
                                percent: 0,
                                status: 'processing',
                                message: readyResult.message
                            });
                        }
                    } catch (progressError) {
                        updateSidebarProgress(viewportName, {
                            percent: 0,
                            status: 'processing',
                            message: readyResult.message
                        });
                    }
                } catch (error) {
                    console.error('Error polling progress:', error);
                }
            }, 2000);
        }

        async function goToViewer(viewportName) {
            // Simple version: check readiness, then navigate if ready
            const name = viewportName || (currentViewport ? currentViewport.name : null);

            if (!name) {
                alert('No viewport selected');
                return;
            }

            try {
                const response = await fetch(`/api/viewports/${name}/is-ready`);
                const result = await response.json();

                if (result.ready) {
                    // Get selected viewer type
                    const viewerType = document.getElementById('viewer-type-selector').value;

                    // Save preference to localStorage
                    localStorage.setItem('preferredViewer', viewerType);

                    console.log(`[VIEWER] ${name} is ready, navigating to ${viewerType}`);
                    window.location.href = viewerType;
                } else {
                    alert(`Data not ready yet.\n\n${result.message}\n\nPlease wait and try again.`);
                }
            } catch (error) {
                console.error('[VIEWER] Error checking readiness:', error);
                alert('Error checking data status');
            }
        }

        // Delete a viewport
        async function deleteViewport(name) {
            if (!confirm(`Are you sure you want to delete the "${name}" viewport?`)) {
                return;
            }

            try {
                const response = await fetch('/api/viewports/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                const data = await response.json();

                if (data.success) {
                    console.log(`‚úì Deleted viewport: ${name}`);
                    loadViewports();

                    // If deleted viewport was active, reload current
                    if (currentViewport && currentViewport.name === name) {
                        loadCurrentViewport();
                    }
                } else {
                    alert(`Error deleting viewport: ${data.error}`);
                }
            } catch (error) {
                alert(`Error deleting viewport: ${error.message}`);
                console.error('Delete error:', error);
            }
        }

        // Update current viewport display
        function updateCurrentViewportDisplay() {
            if (!currentViewport) return;

            document.getElementById('currentName').textContent = currentViewport.name || currentViewport.viewport_id;

            const bounds = currentViewport.bounds;
            const boundsText = `
Min Lat: ${bounds.minLat.toFixed(4)}¬∞
Max Lat: ${bounds.maxLat.toFixed(4)}¬∞
Min Lon: ${bounds.minLon.toFixed(4)}¬∞
Max Lon: ${bounds.maxLon.toFixed(4)}¬∞
            `.trim();

            document.getElementById('currentBounds').textContent = boundsText;
        }

        // Draw viewport box on map
        function drawViewportBox() {
            if (!currentViewport) return;

            const bounds = currentViewport.bounds;
            const latLngBounds = [
                [bounds.minLat, bounds.minLon],
                [bounds.maxLat, bounds.maxLon]
            ];

            if (viewportBox) {
                map.removeLayer(viewportBox);
            }

            viewportBox = L.rectangle(latLngBounds, {
                color: '#667eea',
                weight: 2,
                opacity: 0.8,
                fill: true,
                fillColor: '#667eea',
                fillOpacity: 0.1
            }).addTo(map);

            // Calculate zoom level based on viewport extent
            const latExtent = bounds.maxLat - bounds.minLat;
            const lonExtent = bounds.maxLon - bounds.minLon;
            const maxExtent = Math.max(latExtent, lonExtent);

            let zoom = 12;
            if (maxExtent < 0.05) zoom = 15;
            else if (maxExtent < 0.1) zoom = 14;
            else if (maxExtent < 0.2) zoom = 13;
            else if (maxExtent < 0.5) zoom = 12;
            else if (maxExtent < 1.0) zoom = 11;
            else zoom = 10;

            // Center map on viewport
            const center = currentViewport.center;
            map.setView([center[0], center[1]], zoom);
        }

        // Load viewports list
        async function loadViewports() {
            try {
                const response = await fetch('/api/viewports/list');
                const data = await response.json();

                if (data.success) {
                    displayViewports(data.viewports);
                }
            } catch (error) {
                console.error('Error loading viewports:', error);
            }
        }

        // Display viewports in list
        function displayViewports(viewports) {
            const list = document.getElementById('viewportsList');

            if (viewports.length === 0) {
                list.innerHTML = '<p style="color: #999; font-size: 12px;">No viewports found</p>';
                return;
            }

            list.innerHTML = viewports.map(vp => {
                const isActive = vp.is_active ? 'active' : '';
                const bounds = vp.bounds;
                const coordsText = `${bounds.minLon.toFixed(4)}¬∞, ${bounds.minLat.toFixed(4)}¬∞`;
                const dataSize = vp.data_size_mb || 0;
                const sizeText = dataSize > 1000
                    ? `${(dataSize / 1024).toFixed(1)} GB`
                    : `${dataSize.toFixed(0)} MB`;

                return `
                    <div class="viewport-item ${isActive}">
                        <div class="viewport-item-name" onclick="switchViewport('${vp.name}')" style="cursor: pointer;">${vp.name}</div>
                        <div class="viewport-item-coords">${coordsText}</div>
                        <div class="viewport-item-coords" style="color: #0066cc; font-weight: 500; margin-top: 3px;">üíæ ${sizeText}</div>
                        <div class="viewport-item-actions">
                            <button class="viewport-item-btn" onclick="switchViewport('${vp.name}')">Select</button>
                            <button class="viewport-item-btn delete" onclick="deleteViewport('${vp.name}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Format bytes to human readable
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Format elapsed time
        function formatElapsed(startTimeStr) {
            if (!startTimeStr) return '';
            const start = new Date(startTimeStr);
            const now = new Date();
            const elapsed = Math.floor((now - start) / 1000);
            if (elapsed < 60) return `${elapsed}s`;
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            return `${mins}m ${secs}s`;
        }

        // Get stage emoji based on status/message
        function getStageEmoji(status, message) {
            const msgLower = (message || '').toLowerCase();
            if (status === 'complete') return '‚úì';
            if (status === 'error') return '‚úó';
            if (msgLower.includes('download')) return 'üì•';
            if (msgLower.includes('rgb')) return 'üé®';
            if (msgLower.includes('pyramid')) return 'üî∫';
            if (msgLower.includes('faiss')) return 'üîç';
            if (msgLower.includes('umap') || msgLower.includes('pca')) return 'üìä';
            return '‚è≥';
        }

        // Update sidebar progress display with full details
        function updateSidebarProgress(viewportName, progress) {
            const percent = progress.percent || 0;
            const status = progress.status || 'processing';
            const message = progress.message || '';
            const currentFile = progress.current_file || '';
            const currentValue = progress.current_value || 0;
            const totalValue = progress.total_value || 0;
            const startTime = progress.start_time || '';

            document.getElementById('processingViewportName').textContent = viewportName;
            document.getElementById('processingProgressBar').style.width = `${percent}%`;
            document.getElementById('processingPercent').textContent = `${percent}%`;
            document.getElementById('processingElapsed').textContent = formatElapsed(startTime);

            const emoji = getStageEmoji(status, message);
            document.getElementById('processingStage').textContent = `${emoji} ${message}`;

            // Show current file if available
            if (currentFile) {
                document.getElementById('processingFile').textContent = currentFile;
                document.getElementById('processingFile').style.display = 'block';
            } else {
                document.getElementById('processingFile').style.display = 'none';
            }

            // Show bytes progress if available (for downloads)
            if (totalValue > 0 && currentValue > 0) {
                document.getElementById('processingBytes').textContent =
                    `${formatBytes(currentValue)} / ${formatBytes(totalValue)}`;
                document.getElementById('processingBytes').style.display = 'block';
            } else {
                document.getElementById('processingBytes').style.display = 'none';
            }

            // Additional status message
            if (status === 'error') {
                document.getElementById('processingMessage').textContent = 'Error occurred - check logs';
                document.getElementById('processingMessage').style.color = '#d32f2f';
            } else if (status === 'complete') {
                document.getElementById('processingMessage').textContent = 'Processing complete!';
                document.getElementById('processingMessage').style.color = '#388e3c';
            } else {
                document.getElementById('processingMessage').textContent = '';
                document.getElementById('processingMessage').style.color = '#555';
            }
        }

        async function waitForViewportReady(viewportName, maxWaitMs = 1800000) {
            // Poll both is-ready and download progress every 2 seconds
            const startTime = Date.now();
            const pollIntervalMs = 2000;  // 2 seconds for more responsive progress

            console.log(`[WAIT] Starting to wait for ${viewportName} to be ready...`);

            // Initialize sidebar progress
            updateSidebarProgress(viewportName, {
                percent: 0,
                status: 'starting',
                message: 'Starting pipeline...',
                start_time: new Date().toISOString()
            });

            return new Promise((resolve) => {
                const pollInterval = setInterval(async () => {
                    try {
                        // Check if ready
                        const readyResponse = await fetch(`/api/viewports/${viewportName}/is-ready`);
                        const readyResult = await readyResponse.json();

                        console.log(`[WAIT] ${viewportName}: ${readyResult.message} (ready: ${readyResult.ready})`);

                        if (readyResult.ready) {
                            console.log(`[WAIT] ‚úì ${viewportName} is ready!`);
                            updateSidebarProgress(viewportName, {
                                percent: 100,
                                status: 'complete',
                                message: 'Ready to view!'
                            });
                            clearInterval(pollInterval);
                            resolve(true);
                            return;
                        }

                        // Poll unified pipeline progress (covers all stages: download ‚Üí RGB ‚Üí pyramids ‚Üí FAISS ‚Üí UMAP)
                        try {
                            const progressResponse = await fetch(`/api/operations/progress/${viewportName}_pipeline`);
                            const progress = await progressResponse.json();

                            if (progress.success && progress.status !== 'not_started') {
                                updateSidebarProgress(viewportName, progress);
                                console.log(`[PROGRESS] ${viewportName}: ${progress.percent}% - ${progress.message}`);
                            } else {
                                // No pipeline progress yet, show is-ready message
                                updateSidebarProgress(viewportName, {
                                    percent: 0,
                                    status: 'starting',
                                    message: readyResult.message
                                });
                            }
                        } catch (progressError) {
                            // Progress endpoint not available, just use is-ready message
                            updateSidebarProgress(viewportName, {
                                percent: 0,
                                status: 'processing',
                                message: readyResult.message
                            });
                        }

                        // Check timeout
                        if (Date.now() - startTime > maxWaitMs) {
                            console.log(`[WAIT] ‚úó Timeout waiting for ${viewportName}`);
                            updateSidebarProgress(viewportName, {
                                percent: 0,
                                status: 'error',
                                message: 'Timeout - please try again'
                            });
                            clearInterval(pollInterval);
                            resolve(false);
                            return;
                        }
                    } catch (error) {
                        console.error(`[WAIT] Error checking readiness:`, error);
                    }
                }, pollIntervalMs);
            });
        }

        // Switch to viewport
        async function switchViewport(name) {
            try {
                const response = await fetch('/api/viewports/switch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                const data = await response.json();

                if (data.success) {
                    currentViewport = data.viewport;
                    updateCurrentViewportDisplay();
                    drawViewportBox();
                    loadViewports(); // Refresh list to show active indicator

                    // Check and display data status
                    await checkAndDisplayDataStatus(name);
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error switching viewport:', error);
                alert('Error switching viewport. Check console for details.');
            }
        }

        // Toggle create form
        function toggleCreateForm() {
            const form = document.getElementById('createForm');
            form.classList.toggle('open');

            // Remove viewport box when opening form for clear view
            if (form.classList.contains('open')) {
                if (viewportBox) {
                    map.removeLayer(viewportBox);
                }
            } else {
                // Restore viewport box when closing form
                drawViewportBox();
                document.getElementById('mapInfoLabel').textContent = 'Click on map';
                document.getElementById('mapInfoValue').textContent = 'to select viewport center';
                hideBoundsCoordinates();

                // Reset preview
                if (previewBox) {
                    map.removeLayer(previewBox);
                    previewBox = null;
                }
            }
        }

        // Viewport creation now happens directly from map click in createViewportFromClick()

        // Show status message
        function showStatus(div, type, message) {
            div.textContent = message;
            div.className = `status ${type}`;
            div.style.display = 'block';
        }

        // Disable UI during downloads
        function disableUI() {
            // Disable viewport list
            const viewportItems = document.querySelectorAll('.viewport-item-btn, .viewport-item-name');
            viewportItems.forEach(el => {
                el.style.opacity = '0.5';
                el.style.cursor = 'not-allowed';
                el.style.pointerEvents = 'none';
            });

            // Disable create form button
            const toggleBtn = document.querySelector('.btn-toggle');
            if (toggleBtn) {
                toggleBtn.style.opacity = '0.5';
                toggleBtn.style.cursor = 'not-allowed';
                toggleBtn.style.pointerEvents = 'none';
            }

            // Disable map clicking by disabling the click event
            if (map) {
                map.dragging.disable();
                map.boxZoom.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            }

            // Add overlay message
            const mapContainer = document.querySelector('.map-container');
            if (mapContainer && !document.getElementById('downloadOverlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'downloadOverlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.right = '0';
                overlay.style.bottom = '0';
                overlay.style.background = 'rgba(0, 0, 0, 0.3)';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.zIndex = '1000';
                overlay.style.cursor = 'not-allowed';
                overlay.innerHTML = '<div style="background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.2);"><div style="font-weight: 600; color: #333; margin-bottom: 8px;">Downloading in progress...</div><div style="font-size: 12px; color: #666;">Please wait until the download completes</div></div>';
                mapContainer.appendChild(overlay);
            }
        }

        // Re-enable UI after downloads
        function enableUI() {
            // Re-enable viewport list
            const viewportItems = document.querySelectorAll('.viewport-item-btn, .viewport-item-name');
            viewportItems.forEach(el => {
                el.style.opacity = '1';
                el.style.cursor = 'pointer';
                el.style.pointerEvents = 'auto';
            });

            // Re-enable create form button
            const toggleBtn = document.querySelector('.btn-toggle');
            if (toggleBtn) {
                toggleBtn.style.opacity = '1';
                toggleBtn.style.cursor = 'pointer';
                toggleBtn.style.pointerEvents = 'auto';
            }

            // Re-enable map
            if (map) {
                map.dragging.enable();
                map.boxZoom.enable();
                map.doubleClickZoom.enable();
                map.scrollWheelZoom.enable();
            }

            // Remove overlay
            const overlay = document.getElementById('downloadOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Start downloads and processing
        async function startDownloads() {
            const btn = document.getElementById('downloadBtn');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressLabel = document.getElementById('progressLabel');
            const progressPercent = document.getElementById('progressPercent');
            const statusEl = document.getElementById('downloadStatus');

            btn.disabled = true;
            progressContainer.style.display = 'block';

            // Disable UI while downloading
            disableUI();

            try {
                // Start the download process
                const response = await fetch('/api/downloads/process', {
                    method: 'POST'
                });

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to start downloads');
                }

                const taskId = data.task_id;

                // Poll for progress
                let completed = false;
                let pollCount = 0;
                const maxPolls = 1800; // 30 minutes with 1 second intervals

                while (!completed && pollCount < maxPolls) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    pollCount++;

                    try {
                        const progressResponse = await fetch(`/api/downloads/progress/${taskId}`);
                        const progressData = await progressResponse.json();

                        if (progressData.success) {
                            const progress = progressData.progress || 0;
                            const stage = progressData.stage || 'Processing...';

                            progressBar.style.width = progress + '%';
                            progressPercent.textContent = progress + '%';

                            // Show detailed message if available (e.g., from embeddings download)
                            if (progressData.detailed_message) {
                                progressLabel.textContent = progressData.detailed_message;
                            } else {
                                progressLabel.textContent = stage;
                            }

                            if (progressData.completed) {
                                completed = true;
                            }
                        }
                    } catch (err) {
                        console.error('Progress polling error:', err);
                    }
                }

                if (completed) {
                    progressBar.style.width = '100%';
                    progressPercent.textContent = '100%';
                    progressLabel.textContent = '‚úì All data ready! Opening viewer...';
                    statusEl.innerHTML = '‚úì Done';

                    // Reload viewports to show updated data
                    loadViewports();
                    loadCurrentViewport();

                    // Redirect to viewer after a short delay (using viewport-aware viewer)
                    setTimeout(() => {
                        window.location.href = 'viewer.html';
                    }, 2000);
                } else {
                    throw new Error('Download process timeout');
                }
            } catch (error) {
                progressLabel.textContent = '‚úó Error: ' + error.message;
                statusEl.innerHTML = '‚úó Error';
                btn.disabled = false;
                enableUI(); // Re-enable UI on error
                console.error('Download error:', error);
            }
        }

        // Search viewports
        document.getElementById('viewportSearch').addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase();
            const items = document.querySelectorAll('.viewport-item');

            items.forEach(item => {
                const name = item.querySelector('.viewport-item-name').textContent.toLowerCase();
                item.style.display = name.includes(query) ? '' : 'none';
            });
        });

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', function() {
            // Restore viewer preference from localStorage
            const savedViewer = localStorage.getItem('preferredViewer');
            if (savedViewer) {
                document.getElementById('viewer-type-selector').value = savedViewer;
            }

            initMap();
            initGeocodeSearch();
            loadCurrentViewport();
            loadViewports();
        });
    </script>
</body>
</html>
