<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blore Viewport Manager</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        /* Left Sidebar */
        .sidebar {
            width: 350px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .sidebar-header p {
            font-size: 12px;
            opacity: 0.9;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        /* Search Bar */
        .search-container {
            margin-bottom: 20px;
        }

        .search-container input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
        }

        .search-container input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Viewports List */
        .viewports-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .viewport-item {
            padding: 12px;
            border: 1px solid #eee;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .viewport-item:hover {
            border-color: #667eea;
            background: #f9f9ff;
        }

        .viewport-item.active {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .viewport-item-name {
            font-weight: 600;
            font-size: 13px;
            color: #333;
            margin-bottom: 4px;
        }

        .viewport-item-coords {
            font-size: 11px;
            color: #999;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .viewport-item.active .viewport-item-name {
            color: #667eea;
        }

        .viewport-item-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .viewport-item-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 10px;
            border: 1px solid #ddd;
            background: white;
            color: #666;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .viewport-item-btn:hover {
            background: #f5f5f5;
            border-color: #667eea;
            color: #667eea;
        }

        .viewport-item-btn.delete:hover {
            background: #ffebee;
            border-color: #d32f2f;
            color: #d32f2f;
        }

        /* Current Viewport Panel */
        .current-viewport {
            padding: 12px;
            background: #f9f9ff;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .current-viewport-title {
            font-size: 12px;
            font-weight: 600;
            color: #667eea;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .current-viewport-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }

        .current-viewport-bounds {
            font-size: 11px;
            color: #666;
            font-family: 'Monaco', 'Courier New', monospace;
            line-height: 1.4;
        }

        /* Create New Viewport Form */
        .create-form {
            padding: 12px;
            background: #f5f5f5;
            border-radius: 6px;
            display: none;
        }

        .create-form.open {
            display: block;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
        }

        .form-group input,
        .form-group.input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group.input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .button-group {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 1px solid #667eea;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #f9f9ff;
        }

        .btn-small {
            padding: 6px 10px;
            font-size: 11px;
        }

        .btn-toggle {
            background: white;
            color: #667eea;
            border: 1px solid #ddd;
            width: 100%;
            margin-bottom: 12px;
        }

        .btn-toggle:hover {
            background: #f9f9ff;
        }

        /* Download Section */
        .downloads-section {
            padding: 12px;
            background: #fffaed;
            border: 1px solid #ffe4b5;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .downloads-title {
            font-size: 12px;
            font-weight: 600;
            color: #b8860b;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .download-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-download {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: white;
            color: #b8860b;
            border: 1px solid #daa520;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-download:hover:not(:disabled) {
            background: #fffaed;
            border-color: #b8860b;
        }

        .btn-download:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-download.downloading {
            opacity: 0.8;
            cursor: wait;
        }

        .download-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
        }

        .download-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
        }

        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Status Messages */
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 12px;
            text-align: center;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }

        /* Info Panel on Map */
        .map-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            font-size: 12px;
            max-width: 200px;
            z-index: 400;
        }

        .map-info-label {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 4px;
        }

        .map-info-value {
            font-family: 'Monaco', 'Courier New', monospace;
            color: #333;
            font-size: 11px;
            line-height: 1.4;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Progress Modal */
        #progress-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #progress-overlay.active {
            display: flex;
        }

        #progress-modal {
            background: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        #progress-modal h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }

        #progress-message {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
            word-break: break-word;
        }

        #progress-file {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .progress-bar-container {
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            height: 24px;
            overflow: hidden;
            margin-bottom: 12px;
            position: relative;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: white;
        }

        #progress-percent {
            font-size: 13px;
            color: #666;
            text-align: right;
            margin-bottom: 12px;
        }

        #progress-status {
            font-size: 12px;
            color: #667eea;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #progress-status.complete {
            color: #28a745;
        }

        #progress-status.error {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>Viewport Manager</h1>
            </div>

            <div class="sidebar-content">
                <!-- Search -->
                <div class="section">
                    <div class="section-title">Search Viewports</div>
                    <div class="search-container">
                        <input type="text" id="viewportSearch" placeholder="Search by name...">
                    </div>
                </div>

                <!-- Available Viewports -->
                <div class="section">
                    <div class="section-title">Available Viewports</div>
                    <div id="viewportsList" class="viewports-list">
                        <p style="color: #999; font-size: 12px;">Loading viewports...</p>
                    </div>
                </div>

                <!-- Current Viewport -->
                <div class="section">
                    <div class="current-viewport" id="currentViewport">
                        <div class="current-viewport-title">Active Viewport</div>
                        <div class="current-viewport-name" id="currentName">Loading...</div>
                        <div class="current-viewport-bounds" id="currentBounds"></div>
                    </div>
                </div>

                <!-- Create New Viewport -->
                <div class="section">
                    <button class="btn btn-toggle" onclick="toggleCreateForm()">+ Create New Viewport</button>

                    <div class="create-form" id="createForm">
                        <div style="font-size: 12px; color: #333; margin-bottom: 12px; padding: 10px; background: #e8f4f8; border-radius: 6px; border-left: 3px solid #667eea;">
                            üìç <strong>Click on the map</strong> to create a 5km √ó 5km viewport centered at that location
                        </div>
                        <div id="formFields" style="display: none;">
                            <div class="form-group">
                                <label>Viewport Name (optional)</label>
                                <input type="text" id="viewportName" placeholder="e.g., bangalore_south" class="form-group input">
                            </div>
                            <div style="margin-top: 12px; padding: 0;">
                                <label style="font-weight: 600; margin-bottom: 8px; display: block; font-size: 14px;">Download years (2017-2024):</label>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2017" class="year-checkbox" value="2017" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2017
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2018" class="year-checkbox" value="2018" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2018
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2019" class="year-checkbox" value="2019" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2019
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2020" class="year-checkbox" value="2020" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2020
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2021" class="year-checkbox" value="2021" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2021
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2022" class="year-checkbox" value="2022" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2022
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2023" class="year-checkbox" value="2023" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2023
                                    </label>
                                    <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px; white-space: nowrap;">
                                        <input type="checkbox" id="year2024" class="year-checkbox" value="2024" checked style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;"> 2024
                                    </label>
                                </div>
                                <div style="font-size: 12px; color: #666;">
                                    <button type="button" onclick="selectAllYears()" style="background: none; border: none; color: #667eea; cursor: pointer; text-decoration: underline; padding: 0; font-size: 12px;">Select All</button>
                                    <span style="margin: 0 4px;">‚Ä¢</span>
                                    <button type="button" onclick="selectNoYears()" style="background: none; border: none; color: #667eea; cursor: pointer; text-decoration: underline; padding: 0; font-size: 12px;">Select None</button>
                                </div>
                            </div>
                            <div class="button-group">
                                <button class="btn btn-primary btn-small" onclick="confirmViewportCreation()">Create</button>
                                <button class="btn btn-secondary btn-small" onclick="cancelViewportCreation()">Cancel</button>
                            </div>
                        </div>
                        <div id="closeButton" style="text-align: center; padding: 20px 10px;">
                            <button class="btn btn-secondary" onclick="toggleCreateForm()" style="width: auto;">Close</button>
                        </div>
                    </div>
                </div>

                <!-- Quick Viewer Access -->
                <div class="section" style="margin-top: auto; border-top: 1px solid #ddd; padding-top: 15px;">
                    <div id="dataStatusMessage" style="font-size: 12px; color: #666; margin-bottom: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; display: none;">
                        <div id="dataStatusText">Loading...</div>
                    </div>
                    <button class="btn-download" id="quickViewerBtn" onclick="goToViewer()" style="width: 100%; border-color: #667eea; color: #667eea; background: #f0f4ff;">
                        <span>‚ñ∂ Open Viewer</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            <div class="map-info" id="mapInfo">
                <div class="map-info-label" id="mapInfoLabel">Click on map</div>
                <div class="map-info-value" id="mapInfoValue">to select viewport center</div>
            </div>
        </div>
    </div>

    <!-- Progress Modal -->
    <div id="progress-overlay">
        <div id="progress-modal">
            <h2 id="progress-title">Processing...</h2>
            <div id="progress-file"></div>
            <div id="progress-message"></div>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="progress-bar">
                    <span id="progress-bar-text"></span>
                </div>
            </div>
            <div id="progress-percent">0%</div>
            <div id="progress-status">Starting...</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <script>
        // Global state
        let map;
        let viewportBox;
        let currentViewport = null;
        let mapCenter = [20.0, 78.0]; // Default center of India (will be updated when viewport loads)
        let mapZoom = 5; // Default zoom (will be updated when viewport loads)

        // Viewport selection state
        let previewBox = null;
        let pendingViewportBounds = null;

        // Constants
        const VIEWPORT_SIZE_KM = 5;
        const KM_PER_DEGREE = 111.32; // approximate at equator

        // Convert km to degrees (approximate)
        function kmToDegrees(km, latitude) {
            const latOffset = km / KM_PER_DEGREE;
            const lngOffset = km / (KM_PER_DEGREE * Math.cos(latitude * Math.PI / 180));
            return { latOffset, lngOffset };
        }

        // Initialize map
        function initMap() {
            map = L.map('map').setView(mapCenter, mapZoom);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Add click handler for viewport creation
            map.on('click', function(e) {
                const formOpen = document.getElementById('createForm').classList.contains('open');
                console.log('[MAP CLICK] Form open:', formOpen, 'Latlng:', e.latlng);
                if (formOpen) {
                    console.log('[MAP CLICK] Creating viewport from click at:', e.latlng);
                    createViewportFromClick(e.latlng);
                } else {
                    console.log('[MAP CLICK] Form not open, ignoring click');
                }
            });

            // Add mousemove handler to show preview
            map.on('mousemove', function(e) {
                // Only show preview if form is open AND no location has been selected yet
                if (document.getElementById('createForm').classList.contains('open') && !pendingViewportBounds) {
                    showViewportPreview(e.latlng);
                }
            });

            // Hide preview when mouse leaves map (but keep it visible if location has been selected for naming)
            map.getContainer().addEventListener('mouseout', function() {
                if (previewBox && !pendingViewportBounds) {
                    map.removeLayer(previewBox);
                    previewBox = null;
                }
            });
        }

        // Show preview of 5km √ó 5km viewport
        function showViewportPreview(latlng) {
            const offsets = kmToDegrees(VIEWPORT_SIZE_KM / 2, latlng.lat);

            const bounds = [
                [latlng.lat - offsets.latOffset, latlng.lng - offsets.lngOffset],
                [latlng.lat + offsets.latOffset, latlng.lng + offsets.lngOffset]
            ];

            // Remove old preview
            if (previewBox) {
                map.removeLayer(previewBox);
            }

            // Create new preview
            previewBox = L.rectangle(bounds, {
                color: '#ff6b35',
                weight: 2,
                opacity: 0.7,
                fill: true,
                fillColor: '#ff6b35',
                fillOpacity: 0.1,
                interactive: false
            }).addTo(map);

            previewBox.bringToFront();
        }

        // Prepare viewport for naming (called when map is clicked)
        async function createViewportFromClick(latlng) {
            console.log('[CREATE VIEWPORT] Starting creation at:', latlng);
            const offsets = kmToDegrees(VIEWPORT_SIZE_KM / 2, latlng.lat);

            const minLat = latlng.lat - offsets.latOffset;
            const maxLat = latlng.lat + offsets.latOffset;
            const minLon = latlng.lng - offsets.lngOffset;
            const maxLon = latlng.lng + offsets.lngOffset;

            // Store bounds for later creation
            pendingViewportBounds = {
                bounds: `${minLon.toFixed(6)},${minLat.toFixed(6)},${maxLon.toFixed(6)},${maxLat.toFixed(6)}`,
                autoName: `viewport_${latlng.lat.toFixed(4)}_${latlng.lng.toFixed(4)}`
            };
            console.log('[CREATE VIEWPORT] Bounds:', pendingViewportBounds.bounds);

            // Keep preview visible so user can see where the viewport will be
            // (Don't remove it - let them see the selected area while typing the name)

            // Show the naming form
            document.getElementById('formFields').style.display = 'block';
            document.getElementById('closeButton').style.display = 'none';
            document.getElementById('viewportName').value = '';
            document.getElementById('viewportName').focus();

            document.getElementById('mapInfoLabel').textContent = 'Name your viewport';
            document.getElementById('mapInfoValue').textContent = '(optional)';
            console.log('[CREATE VIEWPORT] Form fields shown, ready for user input');
        }

        // Confirm and create the viewport with optional custom name
        function selectAllYears() {
            document.querySelectorAll('.year-checkbox').forEach(cb => cb.checked = true);
        }

        function selectNoYears() {
            document.querySelectorAll('.year-checkbox').forEach(cb => cb.checked = false);
        }

        function getSelectedYears() {
            const selected = [];
            document.querySelectorAll('.year-checkbox:checked').forEach(cb => {
                selected.push(parseInt(cb.value));
            });
            return selected.sort();
        }

        async function confirmViewportCreation() {
            if (!pendingViewportBounds) return;

            const customName = document.getElementById('viewportName').value.trim();
            const name = customName || pendingViewportBounds.autoName;
            const bounds = pendingViewportBounds.bounds;
            const years = getSelectedYears();

            // Validate that at least one year is selected
            if (years.length === 0) {
                alert('Please select at least one year to download');
                return;
            }

            // Hide form
            document.getElementById('formFields').style.display = 'none';
            document.getElementById('closeButton').style.display = 'block';

            // Show loading state
            document.getElementById('mapInfoLabel').textContent = 'Creating viewport...';
            document.getElementById('mapInfoValue').textContent = `Downloading embeddings for ${years.length} year${years.length > 1 ? 's' : ''}...`;

            try {
                // Create the viewport via API
                const response = await fetch('/api/viewports/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bounds, name, description: `${VIEWPORT_SIZE_KM}km √ó ${VIEWPORT_SIZE_KM}km`, years })
                });

                const data = await response.json();

                if (data.success) {
                    // Remove preview box
                    if (previewBox) {
                        map.removeLayer(previewBox);
                        previewBox = null;
                    }

                    // Check if data is being prepared in background
                    if (data.data_preparing) {
                        // Data is being downloaded/processed - show real-time progress
                        console.log('[VIEWPORT CREATE] Data preparing in background:', data.message);

                        // Show progress modal with real-time updates
                        await pollAllOperations(name);

                        // After operations complete, switch to the new viewport as active
                        await switchViewport(name);
                    } else {
                        // Data is ready immediately, switch to the new viewport as active
                        await switchViewport(name);
                        loadCurrentViewport();

                        // Restore viewport box after form closes
                        drawViewportBox();

                        // Reset message after 3 seconds
                        setTimeout(() => {
                            document.getElementById('mapInfoLabel').textContent = 'Click on map';
                            document.getElementById('mapInfoValue').textContent = 'to select viewport center';
                        }, 3000);
                    }

                    // Clear pending bounds
                    pendingViewportBounds = null;
                } else {
                    document.getElementById('mapInfoLabel').textContent = '‚úó Error creating viewport';
                    document.getElementById('mapInfoValue').textContent = data.error || 'Unknown error';

                    // Remove preview box
                    if (previewBox) {
                        map.removeLayer(previewBox);
                        previewBox = null;
                    }

                    // Close form on error
                    setTimeout(() => {
                        document.getElementById('createForm').classList.remove('open');
                        drawViewportBox();
                    }, 2000);
                }
            } catch (error) {
                document.getElementById('mapInfoLabel').textContent = '‚úó Error creating viewport';
                document.getElementById('mapInfoValue').textContent = error.message;

                // Remove preview box
                if (previewBox) {
                    map.removeLayer(previewBox);
                    previewBox = null;
                }

                // Close form on error
                setTimeout(() => {
                    document.getElementById('createForm').classList.remove('open');
                    drawViewportBox();
                    document.getElementById('mapInfoLabel').textContent = 'Click on map';
                    document.getElementById('mapInfoValue').textContent = 'to select viewport center';
                }, 2000);
            }
        }

        // Cancel viewport creation
        function cancelViewportCreation() {
            document.getElementById('formFields').style.display = 'none';
            document.getElementById('closeButton').style.display = 'block';
            document.getElementById('viewportName').value = '';
            pendingViewportBounds = null;

            // Remove preview box
            if (previewBox) {
                map.removeLayer(previewBox);
                previewBox = null;
            }

            document.getElementById('mapInfoLabel').textContent = 'Click on map';
            document.getElementById('mapInfoValue').textContent = 'to select viewport center';
        }

        // Load current viewport
        async function loadCurrentViewport() {
            try {
                const response = await fetch('/api/viewports/current');
                const data = await response.json();

                if (data.success) {
                    currentViewport = data.viewport;
                    updateCurrentViewportDisplay();
                    drawViewportBox();

                    // Check if data exists for this viewport
                    checkViewportData();
                }
            } catch (error) {
                console.error('Error loading current viewport:', error);
            }
        }

        // Check if pyramids exist for current viewport (with timeout)
        async function checkViewportData() {
            // Run check asynchronously without blocking page load
            setTimeout(async () => {
                try {
                    // Check multiple possible locations for pyramid metadata
                    const pyramidPaths = [
                        'pyramids/2024/pyramid_metadata.json',
                        'pyramids/pyramid_metadata.json',
                        'pyramids/2024/level_0.tif'
                    ];

                    let hasData = false;

                    // Check each path with a 2-second timeout
                    for (const path of pyramidPaths) {
                        try {
                            const controller = new AbortController();
                            const timeout = setTimeout(() => controller.abort(), 2000);

                            const response = await fetch(path, {
                                method: 'HEAD',
                                signal: controller.signal
                            });

                            clearTimeout(timeout);

                            if (response.ok) {
                                hasData = true;
                                break;
                            }
                        } catch (e) {
                            // Continue to next path (timeout or network error)
                        }
                    }

                    const downloadBtn = document.getElementById('downloadBtn');
                    const viewerBtn = document.getElementById('viewerBtn');

                    if (!downloadBtn || !viewerBtn) {
                        return; // Buttons might not exist yet
                    }

                    if (hasData) {
                        console.log('‚úì Pyramid data found - showing viewer button');
                        downloadBtn.style.display = 'none';
                        viewerBtn.style.display = 'block';
                    } else {
                        console.log('‚úó No pyramid data found - showing download button');
                        downloadBtn.style.display = 'block';
                        viewerBtn.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error checking viewport data:', error);
                    // If we can't determine, show download button
                    const downloadBtn = document.getElementById('downloadBtn');
                    const viewerBtn = document.getElementById('viewerBtn');
                    if (downloadBtn && viewerBtn) {
                        downloadBtn.style.display = 'block';
                        viewerBtn.style.display = 'none';
                    }
                }
            }, 100);
        }

        // Go directly to viewer
        async function checkAndDisplayDataStatus(viewportName) {
            try {
                const response = await fetch(`/api/viewports/${viewportName}/data-status`);
                const result = await response.json();
                if (!result.success) return;

                const status = result.data;
                const statusEl = document.getElementById('dataStatusMessage');
                const statusText = document.getElementById('dataStatusText');

                // Build status message
                let message = '';
                let ready = status.pyramids && status.faiss;

                if (status.pyramids && status.faiss) {
                    message = `‚úÖ Ready to view (${status.years_available.length} year${status.years_available.length !== 1 ? 's' : ''})`;
                    statusEl.style.background = '#e8f5e9';
                    statusEl.style.color = '#2e7d32';
                } else {
                    let processing = [];
                    if (!status.pyramids) processing.push('Creating pyramids');
                    if (!status.faiss) processing.push('Building FAISS index');
                    message = `‚è≥ Processing: ${processing.join(', ')}`;
                    statusEl.style.background = '#fff3cd';
                    statusEl.style.color = '#856404';
                }

                statusText.textContent = message;
                statusEl.style.display = 'block';

                // Disable viewer button if data not ready
                const viewerBtn = document.getElementById('quickViewerBtn');
                viewerBtn.disabled = !ready;
                if (!ready) {
                    viewerBtn.style.opacity = '0.5';
                    viewerBtn.style.cursor = 'not-allowed';
                } else {
                    viewerBtn.style.opacity = '1';
                    viewerBtn.style.cursor = 'pointer';
                }
            } catch (error) {
                console.error('Error checking data status:', error);
            }
        }

        async function goToViewer() {
            // Check data readiness before allowing navigation
            try {
                const response = await fetch(`/api/viewports/${currentViewport.name}/data-status`);
                const result = await response.json();
                const status = result.data;

                // Require pyramids and FAISS to be ready
                if (!status.pyramids || !status.faiss) {
                    let missing = [];
                    if (!status.pyramids) missing.push('Pyramids');
                    if (!status.faiss) missing.push('FAISS index');

                    alert(`Data not ready yet.\n\nStill processing: ${missing.join(', ')}\n\nPlease wait a few minutes and try again.`);
                    return;
                }

                // Data is ready, navigate to viewer
                window.location.href = 'viewer.html';
            } catch (error) {
                console.error('Error checking data status:', error);
                alert('Error checking data status. Please try again.');
            }
        }

        // Delete a viewport
        async function deleteViewport(name) {
            if (!confirm(`Are you sure you want to delete the "${name}" viewport?`)) {
                return;
            }

            try {
                const response = await fetch('/api/viewports/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                const data = await response.json();

                if (data.success) {
                    console.log(`‚úì Deleted viewport: ${name}`);
                    loadViewports();

                    // If deleted viewport was active, reload current
                    if (currentViewport && currentViewport.name === name) {
                        loadCurrentViewport();
                    }
                } else {
                    alert(`Error deleting viewport: ${data.error}`);
                }
            } catch (error) {
                alert(`Error deleting viewport: ${error.message}`);
                console.error('Delete error:', error);
            }
        }

        // Update current viewport display
        function updateCurrentViewportDisplay() {
            if (!currentViewport) return;

            document.getElementById('currentName').textContent = currentViewport.name || currentViewport.viewport_id;

            const bounds = currentViewport.bounds;
            const boundsText = `
Min Lat: ${bounds.minLat.toFixed(4)}¬∞
Max Lat: ${bounds.maxLat.toFixed(4)}¬∞
Min Lon: ${bounds.minLon.toFixed(4)}¬∞
Max Lon: ${bounds.maxLon.toFixed(4)}¬∞
            `.trim();

            document.getElementById('currentBounds').textContent = boundsText;
        }

        // Draw viewport box on map
        function drawViewportBox() {
            if (!currentViewport) return;

            const bounds = currentViewport.bounds;
            const latLngBounds = [
                [bounds.minLat, bounds.minLon],
                [bounds.maxLat, bounds.maxLon]
            ];

            if (viewportBox) {
                map.removeLayer(viewportBox);
            }

            viewportBox = L.rectangle(latLngBounds, {
                color: '#667eea',
                weight: 2,
                opacity: 0.8,
                fill: true,
                fillColor: '#667eea',
                fillOpacity: 0.1
            }).addTo(map);

            // Calculate zoom level based on viewport extent
            const latExtent = bounds.maxLat - bounds.minLat;
            const lonExtent = bounds.maxLon - bounds.minLon;
            const maxExtent = Math.max(latExtent, lonExtent);

            let zoom = 12;
            if (maxExtent < 0.05) zoom = 15;
            else if (maxExtent < 0.1) zoom = 14;
            else if (maxExtent < 0.2) zoom = 13;
            else if (maxExtent < 0.5) zoom = 12;
            else if (maxExtent < 1.0) zoom = 11;
            else zoom = 10;

            // Center map on viewport
            const center = currentViewport.center;
            map.setView([center[0], center[1]], zoom);
        }

        // Load viewports list
        async function loadViewports() {
            try {
                const response = await fetch('/api/viewports/list');
                const data = await response.json();

                if (data.success) {
                    displayViewports(data.viewports);
                }
            } catch (error) {
                console.error('Error loading viewports:', error);
            }
        }

        // Display viewports in list
        function displayViewports(viewports) {
            const list = document.getElementById('viewportsList');

            if (viewports.length === 0) {
                list.innerHTML = '<p style="color: #999; font-size: 12px;">No viewports found</p>';
                return;
            }

            list.innerHTML = viewports.map(vp => {
                const isActive = vp.is_active ? 'active' : '';
                const bounds = vp.bounds;
                const coordsText = `${bounds.minLon.toFixed(4)}¬∞, ${bounds.minLat.toFixed(4)}¬∞`;
                const dataSize = vp.data_size_mb || 0;
                const sizeText = dataSize > 1000
                    ? `${(dataSize / 1024).toFixed(1)} GB`
                    : `${dataSize.toFixed(0)} MB`;

                return `
                    <div class="viewport-item ${isActive}">
                        <div class="viewport-item-name" onclick="switchViewport('${vp.name}')" style="cursor: pointer;">${vp.name}</div>
                        <div class="viewport-item-coords">${coordsText}</div>
                        <div class="viewport-item-coords" style="color: #0066cc; font-weight: 500; margin-top: 3px;">üíæ ${sizeText}</div>
                        <div class="viewport-item-actions">
                            <button class="viewport-item-btn" onclick="switchViewport('${vp.name}')">Select</button>
                            <button class="viewport-item-btn delete" onclick="deleteViewport('${vp.name}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Progress tracking functions
        let progressPollInterval = null;

        function showProgressModal(title) {
            console.log(`[PROGRESS] Starting operation: ${title}`);
            document.getElementById('progress-title').textContent = title;
            document.getElementById('progress-overlay').classList.add('active');
        }

        function hideProgressModal() {
            console.log('[PROGRESS] Hiding progress modal');
            document.getElementById('progress-overlay').classList.remove('active');

            if (progressPollInterval) {
                clearInterval(progressPollInterval);
                progressPollInterval = null;
            }
        }

        function updateProgressUI(data) {
            // Update message
            document.getElementById('progress-message').textContent = data.message || '';

            // Update current file
            const fileEl = document.getElementById('progress-file');
            if (data.current_file) {
                fileEl.textContent = `File: ${data.current_file}`;
                fileEl.style.display = 'block';
            } else {
                fileEl.style.display = 'none';
            }

            // Update progress bar
            const percent = data.percent || 0;
            const progressBar = document.getElementById('progress-bar');
            const progressBarText = document.getElementById('progress-bar-text');
            progressBar.style.width = percent + '%';
            if (percent > 0) {
                progressBarText.textContent = percent + '%';
            }

            // Update percent display
            document.getElementById('progress-percent').textContent = percent + '%';

            // Update status
            const statusEl = document.getElementById('progress-status');
            statusEl.textContent = (data.status || 'processing').toUpperCase();
            statusEl.className = 'progress-status ' + (data.status || 'processing');
        }

        async function pollOperationProgress(operationId, title) {
            showProgressModal(title);

            return new Promise((resolve) => {
                progressPollInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`/api/operations/progress/${operationId}`);
                        const result = await response.json();

                        if (result.success && result.status) {
                            const data = result;
                            updateProgressUI(data);

                            console.log(`[PROGRESS] ${operationId}: ${data.message} (${data.percent}%)`);

                            // Check if operation is complete or failed
                            if (data.status === 'complete' || data.status === 'error') {
                                // Show final message for 2 seconds
                                setTimeout(() => {
                                    hideProgressModal();
                                    resolve();
                                }, 2000);

                                // Clear interval
                                clearInterval(progressPollInterval);
                                progressPollInterval = null;
                            }
                        }
                    } catch (error) {
                        console.error('[PROGRESS] Error polling progress:', error);
                    }
                }, 500); // Poll every 500ms
            });
        }

        async function pollAllOperations(viewportId) {
            const operations = ['embeddings', 'pyramids', 'faiss'];
            const titles = {
                'embeddings': 'üì• Downloading Embeddings',
                'pyramids': 'üî® Creating Pyramids',
                'faiss': 'üîç Building FAISS Index'
            };

            for (const op of operations) {
                const operationId = `${viewportId}_${op}`;
                try {
                    const response = await fetch(`/api/operations/progress/${operationId}`);
                    const result = await response.json();

                    if (result.success && result.status && result.status !== 'complete') {
                        console.log(`[PROGRESS] Found ongoing operation: ${operationId}`);
                        await pollOperationProgress(operationId, titles[op]);
                        // Small delay before checking next operation
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                } catch (error) {
                    // Operation not found - continue to next
                }
            }
        }

        // Switch to viewport
        async function switchViewport(name) {
            try {
                const response = await fetch('/api/viewports/switch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                const data = await response.json();

                if (data.success) {
                    currentViewport = data.viewport;
                    updateCurrentViewportDisplay();
                    drawViewportBox();
                    loadViewports(); // Refresh list to show active indicator

                    // Check and display data status
                    await checkAndDisplayDataStatus(name);

                    // Show progress tracking for any ongoing operations
                    if (!data.faiss_ready) {
                        console.log(`[VIEWPORT] Starting progress tracking for "${name}"`);
                        await pollAllOperations(name);
                        // Update status after operations complete
                        await checkAndDisplayDataStatus(name);
                    } else {
                        console.log(`[VIEWPORT] FAISS index ready for "${name}"`);
                    }
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error switching viewport:', error);
                alert('Error switching viewport. Check console for details.');
            }
        }

        // Toggle create form
        function toggleCreateForm() {
            const form = document.getElementById('createForm');
            form.classList.toggle('open');

            // Remove viewport box when opening form for clear view
            if (form.classList.contains('open')) {
                if (viewportBox) {
                    map.removeLayer(viewportBox);
                }
            } else {
                // Restore viewport box when closing form
                drawViewportBox();
                document.getElementById('mapInfoLabel').textContent = 'Click on map';
                document.getElementById('mapInfoValue').textContent = 'to select viewport center';

                // Reset preview
                if (previewBox) {
                    map.removeLayer(previewBox);
                    previewBox = null;
                }
            }
        }

        // Viewport creation now happens directly from map click in createViewportFromClick()

        // Show status message
        function showStatus(div, type, message) {
            div.textContent = message;
            div.className = `status ${type}`;
            div.style.display = 'block';
        }

        // Disable UI during downloads
        function disableUI() {
            // Disable viewport list
            const viewportItems = document.querySelectorAll('.viewport-item-btn, .viewport-item-name');
            viewportItems.forEach(el => {
                el.style.opacity = '0.5';
                el.style.cursor = 'not-allowed';
                el.style.pointerEvents = 'none';
            });

            // Disable create form button
            const toggleBtn = document.querySelector('.btn-toggle');
            if (toggleBtn) {
                toggleBtn.style.opacity = '0.5';
                toggleBtn.style.cursor = 'not-allowed';
                toggleBtn.style.pointerEvents = 'none';
            }

            // Disable map clicking by disabling the click event
            if (map) {
                map.dragging.disable();
                map.boxZoom.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            }

            // Add overlay message
            const mapContainer = document.querySelector('.map-container');
            if (mapContainer && !document.getElementById('downloadOverlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'downloadOverlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.right = '0';
                overlay.style.bottom = '0';
                overlay.style.background = 'rgba(0, 0, 0, 0.3)';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.zIndex = '1000';
                overlay.style.cursor = 'not-allowed';
                overlay.innerHTML = '<div style="background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.2);"><div style="font-weight: 600; color: #333; margin-bottom: 8px;">Downloading in progress...</div><div style="font-size: 12px; color: #666;">Please wait until the download completes</div></div>';
                mapContainer.appendChild(overlay);
            }
        }

        // Re-enable UI after downloads
        function enableUI() {
            // Re-enable viewport list
            const viewportItems = document.querySelectorAll('.viewport-item-btn, .viewport-item-name');
            viewportItems.forEach(el => {
                el.style.opacity = '1';
                el.style.cursor = 'pointer';
                el.style.pointerEvents = 'auto';
            });

            // Re-enable create form button
            const toggleBtn = document.querySelector('.btn-toggle');
            if (toggleBtn) {
                toggleBtn.style.opacity = '1';
                toggleBtn.style.cursor = 'pointer';
                toggleBtn.style.pointerEvents = 'auto';
            }

            // Re-enable map
            if (map) {
                map.dragging.enable();
                map.boxZoom.enable();
                map.doubleClickZoom.enable();
                map.scrollWheelZoom.enable();
            }

            // Remove overlay
            const overlay = document.getElementById('downloadOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Start downloads and processing
        async function startDownloads() {
            const btn = document.getElementById('downloadBtn');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressLabel = document.getElementById('progressLabel');
            const progressPercent = document.getElementById('progressPercent');
            const statusEl = document.getElementById('downloadStatus');

            btn.disabled = true;
            progressContainer.style.display = 'block';

            // Disable UI while downloading
            disableUI();

            try {
                // Start the download process
                const response = await fetch('/api/downloads/process', {
                    method: 'POST'
                });

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to start downloads');
                }

                const taskId = data.task_id;

                // Poll for progress
                let completed = false;
                let pollCount = 0;
                const maxPolls = 1800; // 30 minutes with 1 second intervals

                while (!completed && pollCount < maxPolls) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    pollCount++;

                    try {
                        const progressResponse = await fetch(`/api/downloads/progress/${taskId}`);
                        const progressData = await progressResponse.json();

                        if (progressData.success) {
                            const progress = progressData.progress || 0;
                            const stage = progressData.stage || 'Processing...';

                            progressBar.style.width = progress + '%';
                            progressPercent.textContent = progress + '%';

                            // Show detailed message if available (e.g., from embeddings download)
                            if (progressData.detailed_message) {
                                progressLabel.textContent = progressData.detailed_message;
                            } else {
                                progressLabel.textContent = stage;
                            }

                            if (progressData.completed) {
                                completed = true;
                            }
                        }
                    } catch (err) {
                        console.error('Progress polling error:', err);
                    }
                }

                if (completed) {
                    progressBar.style.width = '100%';
                    progressPercent.textContent = '100%';
                    progressLabel.textContent = '‚úì All data ready! Opening viewer...';
                    statusEl.innerHTML = '‚úì Done';

                    // Reload viewports to show updated data
                    loadViewports();
                    loadCurrentViewport();

                    // Redirect to viewer after a short delay (using viewport-aware viewer)
                    setTimeout(() => {
                        window.location.href = 'viewer.html';
                    }, 2000);
                } else {
                    throw new Error('Download process timeout');
                }
            } catch (error) {
                progressLabel.textContent = '‚úó Error: ' + error.message;
                statusEl.innerHTML = '‚úó Error';
                btn.disabled = false;
                enableUI(); // Re-enable UI on error
                console.error('Download error:', error);
            }
        }

        // Search viewports
        document.getElementById('viewportSearch').addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase();
            const items = document.querySelectorAll('.viewport-item');

            items.forEach(item => {
                const name = item.querySelector('.viewport-item-name').textContent.toLowerCase();
                item.style.display = name.includes(query) ? '' : 'none';
            });
        });

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', function() {
            initMap();
            loadCurrentViewport();
            loadViewports();
        });
    </script>
</body>
</html>
